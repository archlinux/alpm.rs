/* automatically generated by rust-bindgen 0.70.1 */

pub type __mode_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type mode_t = __mode_t;
pub type off_t = __off_t;
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_list_t {
    pub data: *mut ::std::os::raw::c_void,
    pub prev: *mut _alpm_list_t,
    pub next: *mut _alpm_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_list_t"][::std::mem::size_of::<_alpm_list_t>() - 24usize];
    ["Alignment of _alpm_list_t"][::std::mem::align_of::<_alpm_list_t>() - 8usize];
    ["Offset of field: _alpm_list_t::data"][::std::mem::offset_of!(_alpm_list_t, data) - 0usize];
    ["Offset of field: _alpm_list_t::prev"][::std::mem::offset_of!(_alpm_list_t, prev) - 8usize];
    ["Offset of field: _alpm_list_t::next"][::std::mem::offset_of!(_alpm_list_t, next) - 16usize];
};
pub type alpm_list_t = _alpm_list_t;
pub type alpm_list_fn_free =
    ::std::option::Option<unsafe extern "C" fn(item: *mut ::std::os::raw::c_void)>;
pub type alpm_list_fn_cmp = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn alpm_list_free(list: *mut alpm_list_t);
}
extern "C" {
    pub fn alpm_list_free_inner(list: *mut alpm_list_t, fn_: alpm_list_fn_free);
}
extern "C" {
    pub fn alpm_list_add(
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_append(
        list: *mut *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_append_strdup(
        list: *mut *mut alpm_list_t,
        data: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_add_sorted(
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_join(first: *mut alpm_list_t, second: *mut alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_mmerge(
        left: *mut alpm_list_t,
        right: *mut alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_msort(
        list: *mut alpm_list_t,
        n: usize,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove_item(
        haystack: *mut alpm_list_t,
        item: *mut alpm_list_t,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove_str(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_char,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove_dupes(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_strdup(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_copy(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_copy_data(list: *const alpm_list_t, size: usize) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_reverse(list: *mut alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_nth(list: *const alpm_list_t, n: usize) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_next(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_previous(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_last(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_count(list: *const alpm_list_t) -> usize;
}
extern "C" {
    pub fn alpm_list_find(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alpm_list_find_ptr(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alpm_list_find_str(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn alpm_list_cmp_unsorted(
        left: *const alpm_list_t,
        right: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_list_diff_sorted(
        left: *const alpm_list_t,
        right: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
        onlyleft: *mut *mut alpm_list_t,
        onlyright: *mut *mut alpm_list_t,
    );
}
extern "C" {
    pub fn alpm_list_diff(
        lhs: *const alpm_list_t,
        rhs: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_to_array(
        list: *const alpm_list_t,
        n: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " The libalpm context handle.\n\n This struct represents an instance of libalpm.\n @ingroup libalpm_handle"]
pub type alpm_handle_t = u8;
#[doc = " A database.\n\n A database is a container that stores metadata about packages.\n\n A database can be located on the local filesystem or on a remote server.\n\n To use a database, it must first be registered via \\link alpm_register_syncdb \\endlink.\n If the database is already present in dbpath then it will be usable. Otherwise,\n the database needs to be downloaded using \\link alpm_db_update \\endlink. Even if the\n source of the database is the local filesystem.\n\n After this, the database can be used to query packages and groups. Any packages or groups\n from the database will continue to be owned by the database and do not need to be freed by\n the user. They will be freed when the database is unregistered.\n\n Databases are automatically unregistered when the \\link alpm_handle_t \\endlink is released.\n @ingroup libalpm_databases"]
pub type alpm_db_t = u8;
#[doc = " A package.\n\n A package can be loaded from disk via \\link alpm_pkg_load \\endlink or retrieved from a database.\n Packages from databases are automatically freed when the database is unregistered. Packages loaded\n from a file must be freed manually.\n\n Packages can then be queried for metadata or added to a transaction\n to be added or removed from the system.\n @ingroup libalpm_packages"]
pub type alpm_pkg_t = u8;
#[doc = " The extended data type used to store non-standard package data fields\n @ingroup libalpm_packages"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_pkg_xdata_t {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_pkg_xdata_t"][::std::mem::size_of::<_alpm_pkg_xdata_t>() - 16usize];
    ["Alignment of _alpm_pkg_xdata_t"][::std::mem::align_of::<_alpm_pkg_xdata_t>() - 8usize];
    ["Offset of field: _alpm_pkg_xdata_t::name"]
        [::std::mem::offset_of!(_alpm_pkg_xdata_t, name) - 0usize];
    ["Offset of field: _alpm_pkg_xdata_t::value"]
        [::std::mem::offset_of!(_alpm_pkg_xdata_t, value) - 8usize];
};
#[doc = " The extended data type used to store non-standard package data fields\n @ingroup libalpm_packages"]
pub type alpm_pkg_xdata_t = _alpm_pkg_xdata_t;
#[doc = " The time type used by libalpm. Represents a unix time stamp\n @ingroup libalpm_misc"]
pub type alpm_time_t = i64;
#[doc = " File in a package"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_file_t {
    #[doc = " Name of the file"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Size of the file"]
    pub size: off_t,
    #[doc = " The file's permissions"]
    pub mode: mode_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_file_t"][::std::mem::size_of::<_alpm_file_t>() - 24usize];
    ["Alignment of _alpm_file_t"][::std::mem::align_of::<_alpm_file_t>() - 8usize];
    ["Offset of field: _alpm_file_t::name"][::std::mem::offset_of!(_alpm_file_t, name) - 0usize];
    ["Offset of field: _alpm_file_t::size"][::std::mem::offset_of!(_alpm_file_t, size) - 8usize];
    ["Offset of field: _alpm_file_t::mode"][::std::mem::offset_of!(_alpm_file_t, mode) - 16usize];
};
#[doc = " File in a package"]
pub type alpm_file_t = _alpm_file_t;
#[doc = " Package filelist container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_filelist_t {
    #[doc = " Amount of files in the array"]
    pub count: usize,
    #[doc = " An array of files"]
    pub files: *mut alpm_file_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_filelist_t"][::std::mem::size_of::<_alpm_filelist_t>() - 16usize];
    ["Alignment of _alpm_filelist_t"][::std::mem::align_of::<_alpm_filelist_t>() - 8usize];
    ["Offset of field: _alpm_filelist_t::count"]
        [::std::mem::offset_of!(_alpm_filelist_t, count) - 0usize];
    ["Offset of field: _alpm_filelist_t::files"]
        [::std::mem::offset_of!(_alpm_filelist_t, files) - 8usize];
};
#[doc = " Package filelist container"]
pub type alpm_filelist_t = _alpm_filelist_t;
#[doc = " Local package or package file backup entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_backup_t {
    #[doc = " Name of the file (without .pacsave extension)"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Hash of the filename (used internally)"]
    pub hash: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_backup_t"][::std::mem::size_of::<_alpm_backup_t>() - 16usize];
    ["Alignment of _alpm_backup_t"][::std::mem::align_of::<_alpm_backup_t>() - 8usize];
    ["Offset of field: _alpm_backup_t::name"]
        [::std::mem::offset_of!(_alpm_backup_t, name) - 0usize];
    ["Offset of field: _alpm_backup_t::hash"]
        [::std::mem::offset_of!(_alpm_backup_t, hash) - 8usize];
};
#[doc = " Local package or package file backup entry"]
pub type alpm_backup_t = _alpm_backup_t;
extern "C" {
    #[doc = " Determines whether a package filelist contains a given path.\n The provided path should be relative to the install root with no leading\n slashes, e.g. \"etc/localtime\". When searching for directories, the path must\n have a trailing slash.\n @param filelist a pointer to a package filelist\n @param path the path to search for in the package\n @return a pointer to the matching file or NULL if not found"]
    pub fn alpm_filelist_contains(
        filelist: *const alpm_filelist_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut alpm_file_t;
}
#[doc = " Package group"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_group_t {
    #[doc = " group name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " list of alpm_pkg_t packages"]
    pub packages: *mut alpm_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_group_t"][::std::mem::size_of::<_alpm_group_t>() - 16usize];
    ["Alignment of _alpm_group_t"][::std::mem::align_of::<_alpm_group_t>() - 8usize];
    ["Offset of field: _alpm_group_t::name"][::std::mem::offset_of!(_alpm_group_t, name) - 0usize];
    ["Offset of field: _alpm_group_t::packages"]
        [::std::mem::offset_of!(_alpm_group_t, packages) - 8usize];
};
#[doc = " Package group"]
pub type alpm_group_t = _alpm_group_t;
extern "C" {
    #[doc = " Find group members across a list of databases.\n If a member exists in several databases, only the first database is used.\n IgnorePkg is also handled.\n @param dbs the list of alpm_db_t *\n @param name the name of the group\n @return the list of alpm_pkg_t * (caller is responsible for alpm_list_free)"]
    pub fn alpm_find_group_pkgs(
        dbs: *mut alpm_list_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t;
}
#[repr(u32)]
#[doc = " libalpm's error type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_errno_t {
    #[doc = " No error"]
    ALPM_ERR_OK = 0,
    #[doc = " Failed to allocate memory"]
    ALPM_ERR_MEMORY = 1,
    #[doc = " A system error occurred"]
    ALPM_ERR_SYSTEM = 2,
    #[doc = " Permmision denied"]
    ALPM_ERR_BADPERMS = 3,
    #[doc = " Should be a file"]
    ALPM_ERR_NOT_A_FILE = 4,
    #[doc = " Should be a directory"]
    ALPM_ERR_NOT_A_DIR = 5,
    #[doc = " Function was called with invalid arguments"]
    ALPM_ERR_WRONG_ARGS = 6,
    #[doc = " Insufficient disk space"]
    ALPM_ERR_DISK_SPACE = 7,
    #[doc = " Handle should be null"]
    ALPM_ERR_HANDLE_NULL = 8,
    #[doc = " Handle should not be null"]
    ALPM_ERR_HANDLE_NOT_NULL = 9,
    #[doc = " Failed to acquire lock"]
    ALPM_ERR_HANDLE_LOCK = 10,
    #[doc = " Failed to open database"]
    ALPM_ERR_DB_OPEN = 11,
    #[doc = " Failed to create database"]
    ALPM_ERR_DB_CREATE = 12,
    #[doc = " Database should not be null"]
    ALPM_ERR_DB_NULL = 13,
    #[doc = " Database should be null"]
    ALPM_ERR_DB_NOT_NULL = 14,
    #[doc = " The database could not be found"]
    ALPM_ERR_DB_NOT_FOUND = 15,
    #[doc = " Database is invalid"]
    ALPM_ERR_DB_INVALID = 16,
    #[doc = " Database has an invalid signature"]
    ALPM_ERR_DB_INVALID_SIG = 17,
    #[doc = " The localdb is in a newer/older format than libalpm expects"]
    ALPM_ERR_DB_VERSION = 18,
    #[doc = " Failed to write to the database"]
    ALPM_ERR_DB_WRITE = 19,
    #[doc = " Failed to remove entry from database"]
    ALPM_ERR_DB_REMOVE = 20,
    #[doc = " Server URL is in an invalid format"]
    ALPM_ERR_SERVER_BAD_URL = 21,
    #[doc = " The database has no configured servers"]
    ALPM_ERR_SERVER_NONE = 22,
    #[doc = " A transaction is already initialized"]
    ALPM_ERR_TRANS_NOT_NULL = 23,
    #[doc = " A transaction has not been initialized"]
    ALPM_ERR_TRANS_NULL = 24,
    #[doc = " Duplicate target in transaction"]
    ALPM_ERR_TRANS_DUP_TARGET = 25,
    #[doc = " Duplicate filename in transaction"]
    ALPM_ERR_TRANS_DUP_FILENAME = 26,
    #[doc = " A transaction has not been initialized"]
    ALPM_ERR_TRANS_NOT_INITIALIZED = 27,
    #[doc = " Transaction has not been prepared"]
    ALPM_ERR_TRANS_NOT_PREPARED = 28,
    #[doc = " Transaction was aborted"]
    ALPM_ERR_TRANS_ABORT = 29,
    #[doc = " Failed to interrupt transaction"]
    ALPM_ERR_TRANS_TYPE = 30,
    #[doc = " Tried to commit transaction without locking the database"]
    ALPM_ERR_TRANS_NOT_LOCKED = 31,
    #[doc = " A hook failed to run"]
    ALPM_ERR_TRANS_HOOK_FAILED = 32,
    #[doc = " Package not found"]
    ALPM_ERR_PKG_NOT_FOUND = 33,
    #[doc = " Package is in ignorepkg"]
    ALPM_ERR_PKG_IGNORED = 34,
    #[doc = " Package is invalid"]
    ALPM_ERR_PKG_INVALID = 35,
    #[doc = " Package has an invalid checksum"]
    ALPM_ERR_PKG_INVALID_CHECKSUM = 36,
    #[doc = " Package has an invalid signature"]
    ALPM_ERR_PKG_INVALID_SIG = 37,
    #[doc = " Package does not have a signature"]
    ALPM_ERR_PKG_MISSING_SIG = 38,
    #[doc = " Cannot open the package file"]
    ALPM_ERR_PKG_OPEN = 39,
    #[doc = " Failed to remove package files"]
    ALPM_ERR_PKG_CANT_REMOVE = 40,
    #[doc = " Package has an invalid name"]
    ALPM_ERR_PKG_INVALID_NAME = 41,
    #[doc = " Package has an invalid architecture"]
    ALPM_ERR_PKG_INVALID_ARCH = 42,
    #[doc = " Signatures are missing"]
    ALPM_ERR_SIG_MISSING = 43,
    #[doc = " Signatures are invalid"]
    ALPM_ERR_SIG_INVALID = 44,
    #[doc = " Dependencies could not be satisfied"]
    ALPM_ERR_UNSATISFIED_DEPS = 45,
    #[doc = " Conflicting dependencies"]
    ALPM_ERR_CONFLICTING_DEPS = 46,
    #[doc = " Files conflict"]
    ALPM_ERR_FILE_CONFLICTS = 47,
    #[doc = " Download failed"]
    ALPM_ERR_RETRIEVE = 48,
    #[doc = " Invalid Regex"]
    ALPM_ERR_INVALID_REGEX = 49,
    #[doc = " Error in libarchive"]
    ALPM_ERR_LIBARCHIVE = 50,
    #[doc = " Error in libcurl"]
    ALPM_ERR_LIBCURL = 51,
    #[doc = " Error in external download program"]
    ALPM_ERR_EXTERNAL_DOWNLOAD = 52,
    #[doc = " Error in gpgme"]
    ALPM_ERR_GPGME = 53,
    #[doc = " Missing compile-time features"]
    ALPM_ERR_MISSING_CAPABILITY_SIGNATURES = 54,
}
#[doc = " libalpm's error type"]
pub use self::_alpm_errno_t as alpm_errno_t;
extern "C" {
    #[doc = " Returns the current error code from the handle.\n @param handle the context handle\n @return the current error code of the handle"]
    pub fn alpm_errno(handle: *mut alpm_handle_t) -> alpm_errno_t;
}
extern "C" {
    #[doc = " Returns the string corresponding to an error number.\n @param err the error code to get the string for\n @return the string relating to the given error code"]
    pub fn alpm_strerror(err: alpm_errno_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initializes the library.\n Creates handle, connects to database and creates lockfile.\n This must be called before any other functions are called.\n @param root the root path for all filesystem operations\n @param dbpath the absolute path to the libalpm database\n @param err an optional variable to hold any error return codes\n @return a context handle on success, NULL on error, err will be set if provided"]
    pub fn alpm_initialize(
        root: *const ::std::os::raw::c_char,
        dbpath: *const ::std::os::raw::c_char,
        err: *mut alpm_errno_t,
    ) -> *mut alpm_handle_t;
}
extern "C" {
    #[doc = " Release the library.\n Disconnects from the database, removes handle and lockfile\n This should be the last alpm call you make.\n After this returns, handle should be considered invalid and cannot be reused\n in any way.\n @param handle the context handle\n @return 0 on success, -1 on error"]
    pub fn alpm_release(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
pub mod _alpm_siglevel_t {
    #[doc = " PGP signature verification options"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Packages require a signature"]
    pub const ALPM_SIG_PACKAGE: Type = 1;
    #[doc = " Packages do not require a signature,\n but check packages that do have signatures"]
    pub const ALPM_SIG_PACKAGE_OPTIONAL: Type = 2;
    #[doc = " Packages do not require a signature,\n but check packages that do have signatures"]
    pub const ALPM_SIG_PACKAGE_MARGINAL_OK: Type = 4;
    #[doc = " Allow packages with signatures that are unknown trust"]
    pub const ALPM_SIG_PACKAGE_UNKNOWN_OK: Type = 8;
    #[doc = " Databases require a signature"]
    pub const ALPM_SIG_DATABASE: Type = 1024;
    #[doc = " Databases do not require a signature,\n but check databases that do have signatures"]
    pub const ALPM_SIG_DATABASE_OPTIONAL: Type = 2048;
    #[doc = " Allow databases with signatures that are marginal trust"]
    pub const ALPM_SIG_DATABASE_MARGINAL_OK: Type = 4096;
    #[doc = " Allow databases with signatures that are unknown trust"]
    pub const ALPM_SIG_DATABASE_UNKNOWN_OK: Type = 8192;
    #[doc = " The Default siglevel"]
    pub const ALPM_SIG_USE_DEFAULT: Type = 1073741824;
}
#[doc = " PGP signature verification options"]
pub use self::_alpm_siglevel_t::Type as alpm_siglevel_t;
#[repr(u32)]
#[doc = " PGP signature verification status return codes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_sigstatus_t {
    #[doc = " Signature is valid"]
    ALPM_SIGSTATUS_VALID = 0,
    #[doc = " The key has expired"]
    ALPM_SIGSTATUS_KEY_EXPIRED = 1,
    #[doc = " The signature has expired"]
    ALPM_SIGSTATUS_SIG_EXPIRED = 2,
    #[doc = " The key is not in the keyring"]
    ALPM_SIGSTATUS_KEY_UNKNOWN = 3,
    #[doc = " The key has been disabled"]
    ALPM_SIGSTATUS_KEY_DISABLED = 4,
    #[doc = " The signature is invalid"]
    ALPM_SIGSTATUS_INVALID = 5,
}
#[doc = " PGP signature verification status return codes"]
pub use self::_alpm_sigstatus_t as alpm_sigstatus_t;
#[repr(u32)]
#[doc = " The trust level of a PGP key"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_sigvalidity_t {
    #[doc = " The signature is fully trusted"]
    ALPM_SIGVALIDITY_FULL = 0,
    #[doc = " The signature is marginally trusted"]
    ALPM_SIGVALIDITY_MARGINAL = 1,
    #[doc = " The signature is never trusted"]
    ALPM_SIGVALIDITY_NEVER = 2,
    #[doc = " The signature has unknown trust"]
    ALPM_SIGVALIDITY_UNKNOWN = 3,
}
#[doc = " The trust level of a PGP key"]
pub use self::_alpm_sigvalidity_t as alpm_sigvalidity_t;
#[doc = " A PGP key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_pgpkey_t {
    #[doc = " The actual key data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The key's fingerprint"]
    pub fingerprint: *mut ::std::os::raw::c_char,
    #[doc = " UID of the key"]
    pub uid: *mut ::std::os::raw::c_char,
    #[doc = " Name of the key's owner"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Email of the key's owner"]
    pub email: *mut ::std::os::raw::c_char,
    #[doc = " When the key was created"]
    pub created: alpm_time_t,
    #[doc = " When the key expires"]
    pub expires: alpm_time_t,
    #[doc = " The length of the key"]
    pub length: ::std::os::raw::c_uint,
    #[doc = " has the key been revoked"]
    pub revoked: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_pgpkey_t"][::std::mem::size_of::<_alpm_pgpkey_t>() - 64usize];
    ["Alignment of _alpm_pgpkey_t"][::std::mem::align_of::<_alpm_pgpkey_t>() - 8usize];
    ["Offset of field: _alpm_pgpkey_t::data"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, data) - 0usize];
    ["Offset of field: _alpm_pgpkey_t::fingerprint"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, fingerprint) - 8usize];
    ["Offset of field: _alpm_pgpkey_t::uid"][::std::mem::offset_of!(_alpm_pgpkey_t, uid) - 16usize];
    ["Offset of field: _alpm_pgpkey_t::name"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, name) - 24usize];
    ["Offset of field: _alpm_pgpkey_t::email"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, email) - 32usize];
    ["Offset of field: _alpm_pgpkey_t::created"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, created) - 40usize];
    ["Offset of field: _alpm_pgpkey_t::expires"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, expires) - 48usize];
    ["Offset of field: _alpm_pgpkey_t::length"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, length) - 56usize];
    ["Offset of field: _alpm_pgpkey_t::revoked"]
        [::std::mem::offset_of!(_alpm_pgpkey_t, revoked) - 60usize];
};
#[doc = " A PGP key"]
pub type alpm_pgpkey_t = _alpm_pgpkey_t;
#[doc = " Signature result. Contains the key, status, and validity of a given\n signature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_sigresult_t {
    #[doc = " The key of the signature"]
    pub key: alpm_pgpkey_t,
    #[doc = " The status of the signature"]
    pub status: alpm_sigstatus_t,
    #[doc = " The validity of the signature"]
    pub validity: alpm_sigvalidity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_sigresult_t"][::std::mem::size_of::<_alpm_sigresult_t>() - 72usize];
    ["Alignment of _alpm_sigresult_t"][::std::mem::align_of::<_alpm_sigresult_t>() - 8usize];
    ["Offset of field: _alpm_sigresult_t::key"]
        [::std::mem::offset_of!(_alpm_sigresult_t, key) - 0usize];
    ["Offset of field: _alpm_sigresult_t::status"]
        [::std::mem::offset_of!(_alpm_sigresult_t, status) - 64usize];
    ["Offset of field: _alpm_sigresult_t::validity"]
        [::std::mem::offset_of!(_alpm_sigresult_t, validity) - 68usize];
};
#[doc = " Signature result. Contains the key, status, and validity of a given\n signature."]
pub type alpm_sigresult_t = _alpm_sigresult_t;
#[doc = " Signature list. Contains the number of signatures found and a pointer to an\n array of results. The array is of size count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_siglist_t {
    #[doc = " The amount of results in the array"]
    pub count: usize,
    #[doc = " An array of sigresults"]
    pub results: *mut alpm_sigresult_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_siglist_t"][::std::mem::size_of::<_alpm_siglist_t>() - 16usize];
    ["Alignment of _alpm_siglist_t"][::std::mem::align_of::<_alpm_siglist_t>() - 8usize];
    ["Offset of field: _alpm_siglist_t::count"]
        [::std::mem::offset_of!(_alpm_siglist_t, count) - 0usize];
    ["Offset of field: _alpm_siglist_t::results"]
        [::std::mem::offset_of!(_alpm_siglist_t, results) - 8usize];
};
#[doc = " Signature list. Contains the number of signatures found and a pointer to an\n array of results. The array is of size count."]
pub type alpm_siglist_t = _alpm_siglist_t;
extern "C" {
    #[doc = " Check the PGP signature for the given package file.\n @param pkg the package to check\n @param siglist a pointer to storage for signature results\n @return 0 if valid, -1 if an error occurred or signature is invalid"]
    pub fn alpm_pkg_check_pgp_signature(
        pkg: *mut alpm_pkg_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the PGP signature for the given database.\n @param db the database to check\n @param siglist a pointer to storage for signature results\n @return 0 if valid, -1 if an error occurred or signature is invalid"]
    pub fn alpm_db_check_pgp_signature(
        db: *mut alpm_db_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clean up and free a signature result list.\n Note that this does not free the siglist object itself in case that\n was allocated on the stack; this is the responsibility of the caller.\n @param siglist a pointer to storage for signature results\n @return 0 on success, -1 on error"]
    pub fn alpm_siglist_cleanup(siglist: *mut alpm_siglist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a loaded signature in base64 form.\n @param base64_data the signature to attempt to decode\n @param data the decoded data; must be freed by the caller\n @param data_len the length of the returned data\n @return 0 on success, -1 on failure to properly decode"]
    pub fn alpm_decode_signature(
        base64_data: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        data_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Extract the Issuer Key ID from a signature\n @param handle the context handle\n @param identifier the identifier of the key.\n This may be the name of the package or the path to the package.\n @param sig PGP signature\n @param len length of signature\n @param keys a pointer to storage for key IDs\n @return 0 on success, -1 on error"]
    pub fn alpm_extract_keyid(
        handle: *mut alpm_handle_t,
        identifier: *const ::std::os::raw::c_char,
        sig: *const ::std::os::raw::c_uchar,
        len: usize,
        keys: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Types of version constraints in dependency specs."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_depmod_t {
    #[doc = " No version constraint"]
    ALPM_DEP_MOD_ANY = 1,
    #[doc = " Test version equality (package=x.y.z)"]
    ALPM_DEP_MOD_EQ = 2,
    #[doc = " Test for at least a version (package>=x.y.z)"]
    ALPM_DEP_MOD_GE = 3,
    #[doc = " Test for at most a version (package<=x.y.z)"]
    ALPM_DEP_MOD_LE = 4,
    #[doc = " Test for greater than some version (package>x.y.z)"]
    ALPM_DEP_MOD_GT = 5,
    #[doc = " Test for less than some version (package<x.y.z)"]
    ALPM_DEP_MOD_LT = 6,
}
#[doc = " Types of version constraints in dependency specs."]
pub use self::_alpm_depmod_t as alpm_depmod_t;
#[repr(u32)]
#[doc = " File conflict type.\n Whether the conflict results from a file existing on the filesystem, or with\n another target in the transaction."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_fileconflicttype_t {
    #[doc = " The conflict results with a another target in the transaction"]
    ALPM_FILECONFLICT_TARGET = 1,
    #[doc = " The conflict results from a file existing on the filesystem"]
    ALPM_FILECONFLICT_FILESYSTEM = 2,
}
#[doc = " File conflict type.\n Whether the conflict results from a file existing on the filesystem, or with\n another target in the transaction."]
pub use self::_alpm_fileconflicttype_t as alpm_fileconflicttype_t;
#[doc = " The basic dependency type.\n\n This type is used throughout libalpm, not just for dependencies\n but also conflicts and providers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_depend_t {
    #[doc = "  Name of the provider to satisfy this dependency"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "  Version of the provider to match against (optional)"]
    pub version: *mut ::std::os::raw::c_char,
    #[doc = " A description of why this dependency is needed (optional)"]
    pub desc: *mut ::std::os::raw::c_char,
    #[doc = " A hash of name (used internally to speed up conflict checks)"]
    pub name_hash: ::std::os::raw::c_ulong,
    #[doc = " How the version should match against the provider"]
    pub mod_: alpm_depmod_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_depend_t"][::std::mem::size_of::<_alpm_depend_t>() - 40usize];
    ["Alignment of _alpm_depend_t"][::std::mem::align_of::<_alpm_depend_t>() - 8usize];
    ["Offset of field: _alpm_depend_t::name"]
        [::std::mem::offset_of!(_alpm_depend_t, name) - 0usize];
    ["Offset of field: _alpm_depend_t::version"]
        [::std::mem::offset_of!(_alpm_depend_t, version) - 8usize];
    ["Offset of field: _alpm_depend_t::desc"]
        [::std::mem::offset_of!(_alpm_depend_t, desc) - 16usize];
    ["Offset of field: _alpm_depend_t::name_hash"]
        [::std::mem::offset_of!(_alpm_depend_t, name_hash) - 24usize];
    ["Offset of field: _alpm_depend_t::mod_"]
        [::std::mem::offset_of!(_alpm_depend_t, mod_) - 32usize];
};
#[doc = " The basic dependency type.\n\n This type is used throughout libalpm, not just for dependencies\n but also conflicts and providers."]
pub type alpm_depend_t = _alpm_depend_t;
#[doc = " Missing dependency."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_depmissing_t {
    #[doc = " Name of the package that has the dependency"]
    pub target: *mut ::std::os::raw::c_char,
    #[doc = " The dependency that was wanted"]
    pub depend: *mut alpm_depend_t,
    #[doc = " If the depmissing was caused by a conflict, the name of the package\n that would be installed, causing the satisfying package to be removed"]
    pub causingpkg: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_depmissing_t"][::std::mem::size_of::<_alpm_depmissing_t>() - 24usize];
    ["Alignment of _alpm_depmissing_t"][::std::mem::align_of::<_alpm_depmissing_t>() - 8usize];
    ["Offset of field: _alpm_depmissing_t::target"]
        [::std::mem::offset_of!(_alpm_depmissing_t, target) - 0usize];
    ["Offset of field: _alpm_depmissing_t::depend"]
        [::std::mem::offset_of!(_alpm_depmissing_t, depend) - 8usize];
    ["Offset of field: _alpm_depmissing_t::causingpkg"]
        [::std::mem::offset_of!(_alpm_depmissing_t, causingpkg) - 16usize];
};
#[doc = " Missing dependency."]
pub type alpm_depmissing_t = _alpm_depmissing_t;
#[doc = " A conflict that has occurred between two packages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_conflict_t {
    #[doc = " The first package"]
    pub package1: *mut alpm_pkg_t,
    #[doc = " The second package"]
    pub package2: *mut alpm_pkg_t,
    #[doc = " The conflict"]
    pub reason: *mut alpm_depend_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_conflict_t"][::std::mem::size_of::<_alpm_conflict_t>() - 24usize];
    ["Alignment of _alpm_conflict_t"][::std::mem::align_of::<_alpm_conflict_t>() - 8usize];
    ["Offset of field: _alpm_conflict_t::package1"]
        [::std::mem::offset_of!(_alpm_conflict_t, package1) - 0usize];
    ["Offset of field: _alpm_conflict_t::package2"]
        [::std::mem::offset_of!(_alpm_conflict_t, package2) - 8usize];
    ["Offset of field: _alpm_conflict_t::reason"]
        [::std::mem::offset_of!(_alpm_conflict_t, reason) - 16usize];
};
#[doc = " A conflict that has occurred between two packages."]
pub type alpm_conflict_t = _alpm_conflict_t;
#[doc = " File conflict.\n\n A conflict that has happened due to a two packages containing the same file,\n or a package contains a file that is already on the filesystem and not owned\n by that package."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_fileconflict_t {
    #[doc = " The name of the package that caused the conflict"]
    pub target: *mut ::std::os::raw::c_char,
    #[doc = " The type of conflict"]
    pub type_: alpm_fileconflicttype_t,
    #[doc = " The name of the file that the package conflicts with"]
    pub file: *mut ::std::os::raw::c_char,
    #[doc = " The name of the package that also owns the file if there is one"]
    pub ctarget: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_fileconflict_t"][::std::mem::size_of::<_alpm_fileconflict_t>() - 32usize];
    ["Alignment of _alpm_fileconflict_t"][::std::mem::align_of::<_alpm_fileconflict_t>() - 8usize];
    ["Offset of field: _alpm_fileconflict_t::target"]
        [::std::mem::offset_of!(_alpm_fileconflict_t, target) - 0usize];
    ["Offset of field: _alpm_fileconflict_t::type_"]
        [::std::mem::offset_of!(_alpm_fileconflict_t, type_) - 8usize];
    ["Offset of field: _alpm_fileconflict_t::file"]
        [::std::mem::offset_of!(_alpm_fileconflict_t, file) - 16usize];
    ["Offset of field: _alpm_fileconflict_t::ctarget"]
        [::std::mem::offset_of!(_alpm_fileconflict_t, ctarget) - 24usize];
};
#[doc = " File conflict.\n\n A conflict that has happened due to a two packages containing the same file,\n or a package contains a file that is already on the filesystem and not owned\n by that package."]
pub type alpm_fileconflict_t = _alpm_fileconflict_t;
extern "C" {
    #[doc = " Checks dependencies and returns missing ones in a list.\n Dependencies can include versions with depmod operators.\n @param handle the context handle\n @param pkglist the list of local packages\n @param remove an alpm_list_t* of packages to be removed\n @param upgrade an alpm_list_t* of packages to be upgraded (remove-then-upgrade)\n @param reversedeps handles the backward dependencies\n @return an alpm_list_t* of alpm_depmissing_t pointers."]
    pub fn alpm_checkdeps(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
        remove: *mut alpm_list_t,
        upgrade: *mut alpm_list_t,
        reversedeps: ::std::os::raw::c_int,
    ) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Find a package satisfying a specified dependency.\n The dependency can include versions with depmod operators.\n @param pkgs an alpm_list_t* of alpm_pkg_t where the satisfyer will be searched\n @param depstring package or provision name, versioned or not\n @return a alpm_pkg_t* satisfying depstring"]
    pub fn alpm_find_satisfier(
        pkgs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    #[doc = " Find a package satisfying a specified dependency.\n First look for a literal, going through each db one by one. Then look for\n providers. The first satisfyer that belongs to an installed package is\n returned. If no providers belong to an installed package then an\n alpm_question_select_provider_t is created to select the provider.\n The dependency can include versions with depmod operators.\n\n @param handle the context handle\n @param dbs an alpm_list_t* of alpm_db_t where the satisfyer will be searched\n @param depstring package or provision name, versioned or not\n @return a alpm_pkg_t* satisfying depstring"]
    pub fn alpm_find_dbs_satisfier(
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    #[doc = " Check the package conflicts in a database\n\n @param handle the context handle\n @param pkglist the list of packages to check\n\n @return an alpm_list_t of alpm_conflict_t"]
    pub fn alpm_checkconflicts(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
    ) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns a newly allocated string representing the dependency information.\n @param dep a dependency info structure\n @return a formatted string, e.g. \"glibc>=2.12\""]
    pub fn alpm_dep_compute_string(dep: *const alpm_depend_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a newly allocated dependency information parsed from a string\n\\link alpm_dep_free should be used to free the dependency \\endlink\n @param depstring a formatted string, e.g. \"glibc=2.12\"\n @return a dependency info structure"]
    pub fn alpm_dep_from_string(depstring: *const ::std::os::raw::c_char) -> *mut alpm_depend_t;
}
extern "C" {
    #[doc = " Free a dependency info structure\n @param dep struct to free"]
    pub fn alpm_dep_free(dep: *mut alpm_depend_t);
}
extern "C" {
    #[doc = " Free a fileconflict and its members.\n @param conflict the fileconflict to free"]
    pub fn alpm_fileconflict_free(conflict: *mut alpm_fileconflict_t);
}
extern "C" {
    #[doc = " Free a depmissing and its members\n @param miss the depmissing to free"]
    pub fn alpm_depmissing_free(miss: *mut alpm_depmissing_t);
}
extern "C" {
    #[doc = " Free a conflict and its members.\n @param conflict the conflict to free"]
    pub fn alpm_conflict_free(conflict: *mut alpm_conflict_t);
}
#[repr(u32)]
#[doc = " Type of events."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_event_type_t {
    #[doc = " Dependencies will be computed for a package."]
    ALPM_EVENT_CHECKDEPS_START = 1,
    #[doc = " Dependencies were computed for a package."]
    ALPM_EVENT_CHECKDEPS_DONE = 2,
    #[doc = " File conflicts will be computed for a package."]
    ALPM_EVENT_FILECONFLICTS_START = 3,
    #[doc = " File conflicts were computed for a package."]
    ALPM_EVENT_FILECONFLICTS_DONE = 4,
    #[doc = " Dependencies will be resolved for target package."]
    ALPM_EVENT_RESOLVEDEPS_START = 5,
    #[doc = " Dependencies were resolved for target package."]
    ALPM_EVENT_RESOLVEDEPS_DONE = 6,
    #[doc = " Inter-conflicts will be checked for target package."]
    ALPM_EVENT_INTERCONFLICTS_START = 7,
    #[doc = " Inter-conflicts were checked for target package."]
    ALPM_EVENT_INTERCONFLICTS_DONE = 8,
    #[doc = " Processing the package transaction is starting."]
    ALPM_EVENT_TRANSACTION_START = 9,
    #[doc = " Processing the package transaction is finished."]
    ALPM_EVENT_TRANSACTION_DONE = 10,
    #[doc = " Package will be installed/upgraded/downgraded/re-installed/removed; See\n alpm_event_package_operation_t for arguments."]
    ALPM_EVENT_PACKAGE_OPERATION_START = 11,
    #[doc = " Package was installed/upgraded/downgraded/re-installed/removed; See\n alpm_event_package_operation_t for arguments."]
    ALPM_EVENT_PACKAGE_OPERATION_DONE = 12,
    #[doc = " Target package's integrity will be checked."]
    ALPM_EVENT_INTEGRITY_START = 13,
    #[doc = " Target package's integrity was checked."]
    ALPM_EVENT_INTEGRITY_DONE = 14,
    #[doc = " Target package will be loaded."]
    ALPM_EVENT_LOAD_START = 15,
    #[doc = " Target package is finished loading."]
    ALPM_EVENT_LOAD_DONE = 16,
    #[doc = " Scriptlet has printed information; See alpm_event_scriptlet_info_t for\n arguments."]
    ALPM_EVENT_SCRIPTLET_INFO = 17,
    #[doc = " Database files will be downloaded from a repository."]
    ALPM_EVENT_DB_RETRIEVE_START = 18,
    #[doc = " Database files were downloaded from a repository."]
    ALPM_EVENT_DB_RETRIEVE_DONE = 19,
    #[doc = " Not all database files were successfully downloaded from a repository."]
    ALPM_EVENT_DB_RETRIEVE_FAILED = 20,
    #[doc = " Package files will be downloaded from a repository."]
    ALPM_EVENT_PKG_RETRIEVE_START = 21,
    #[doc = " Package files were downloaded from a repository."]
    ALPM_EVENT_PKG_RETRIEVE_DONE = 22,
    #[doc = " Not all package files were successfully downloaded from a repository."]
    ALPM_EVENT_PKG_RETRIEVE_FAILED = 23,
    #[doc = " Disk space usage will be computed for a package."]
    ALPM_EVENT_DISKSPACE_START = 24,
    #[doc = " Disk space usage was computed for a package."]
    ALPM_EVENT_DISKSPACE_DONE = 25,
    #[doc = " An optdepend for another package is being removed; See\n alpm_event_optdep_removal_t for arguments."]
    ALPM_EVENT_OPTDEP_REMOVAL = 26,
    #[doc = " A configured repository database is missing; See\n alpm_event_database_missing_t for arguments."]
    ALPM_EVENT_DATABASE_MISSING = 27,
    #[doc = " Checking keys used to create signatures are in keyring."]
    ALPM_EVENT_KEYRING_START = 28,
    #[doc = " Keyring checking is finished."]
    ALPM_EVENT_KEYRING_DONE = 29,
    #[doc = " Downloading missing keys into keyring."]
    ALPM_EVENT_KEY_DOWNLOAD_START = 30,
    #[doc = " Key downloading is finished."]
    ALPM_EVENT_KEY_DOWNLOAD_DONE = 31,
    #[doc = " A .pacnew file was created; See alpm_event_pacnew_created_t for arguments."]
    ALPM_EVENT_PACNEW_CREATED = 32,
    #[doc = " A .pacsave file was created; See alpm_event_pacsave_created_t for\n arguments."]
    ALPM_EVENT_PACSAVE_CREATED = 33,
    #[doc = " Processing hooks will be started."]
    ALPM_EVENT_HOOK_START = 34,
    #[doc = " Processing hooks is finished."]
    ALPM_EVENT_HOOK_DONE = 35,
    #[doc = " A hook is starting"]
    ALPM_EVENT_HOOK_RUN_START = 36,
    #[doc = " A hook has finished running."]
    ALPM_EVENT_HOOK_RUN_DONE = 37,
}
#[doc = " Type of events."]
pub use self::_alpm_event_type_t as alpm_event_type_t;
#[doc = " An event that may represent any event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_any_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_any_t"][::std::mem::size_of::<_alpm_event_any_t>() - 4usize];
    ["Alignment of _alpm_event_any_t"][::std::mem::align_of::<_alpm_event_any_t>() - 4usize];
    ["Offset of field: _alpm_event_any_t::type_"]
        [::std::mem::offset_of!(_alpm_event_any_t, type_) - 0usize];
};
#[doc = " An event that may represent any event."]
pub type alpm_event_any_t = _alpm_event_any_t;
#[repr(u32)]
#[doc = " An enum over the kind of package operations."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_package_operation_t {
    #[doc = " Package (to be) installed. (No oldpkg)"]
    ALPM_PACKAGE_INSTALL = 1,
    #[doc = " Package (to be) upgraded"]
    ALPM_PACKAGE_UPGRADE = 2,
    #[doc = " Package (to be) re-installed"]
    ALPM_PACKAGE_REINSTALL = 3,
    #[doc = " Package (to be) downgraded"]
    ALPM_PACKAGE_DOWNGRADE = 4,
    #[doc = " Package (to be) removed (No newpkg)"]
    ALPM_PACKAGE_REMOVE = 5,
}
#[doc = " An enum over the kind of package operations."]
pub use self::_alpm_package_operation_t as alpm_package_operation_t;
#[doc = " A package operation event occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_package_operation_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Type of operation"]
    pub operation: alpm_package_operation_t,
    #[doc = " Old package"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " New package"]
    pub newpkg: *mut alpm_pkg_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_package_operation_t"]
        [::std::mem::size_of::<_alpm_event_package_operation_t>() - 24usize];
    ["Alignment of _alpm_event_package_operation_t"]
        [::std::mem::align_of::<_alpm_event_package_operation_t>() - 8usize];
    ["Offset of field: _alpm_event_package_operation_t::type_"]
        [::std::mem::offset_of!(_alpm_event_package_operation_t, type_) - 0usize];
    ["Offset of field: _alpm_event_package_operation_t::operation"]
        [::std::mem::offset_of!(_alpm_event_package_operation_t, operation) - 4usize];
    ["Offset of field: _alpm_event_package_operation_t::oldpkg"]
        [::std::mem::offset_of!(_alpm_event_package_operation_t, oldpkg) - 8usize];
    ["Offset of field: _alpm_event_package_operation_t::newpkg"]
        [::std::mem::offset_of!(_alpm_event_package_operation_t, newpkg) - 16usize];
};
#[doc = " A package operation event occurred."]
pub type alpm_event_package_operation_t = _alpm_event_package_operation_t;
#[doc = " An optional dependency was removed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_optdep_removal_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Package with the optdep"]
    pub pkg: *mut alpm_pkg_t,
    #[doc = " Optdep being removed"]
    pub optdep: *mut alpm_depend_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_optdep_removal_t"]
        [::std::mem::size_of::<_alpm_event_optdep_removal_t>() - 24usize];
    ["Alignment of _alpm_event_optdep_removal_t"]
        [::std::mem::align_of::<_alpm_event_optdep_removal_t>() - 8usize];
    ["Offset of field: _alpm_event_optdep_removal_t::type_"]
        [::std::mem::offset_of!(_alpm_event_optdep_removal_t, type_) - 0usize];
    ["Offset of field: _alpm_event_optdep_removal_t::pkg"]
        [::std::mem::offset_of!(_alpm_event_optdep_removal_t, pkg) - 8usize];
    ["Offset of field: _alpm_event_optdep_removal_t::optdep"]
        [::std::mem::offset_of!(_alpm_event_optdep_removal_t, optdep) - 16usize];
};
#[doc = " An optional dependency was removed."]
pub type alpm_event_optdep_removal_t = _alpm_event_optdep_removal_t;
#[doc = " A scriptlet was ran."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_scriptlet_info_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Line of scriptlet output"]
    pub line: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_scriptlet_info_t"]
        [::std::mem::size_of::<_alpm_event_scriptlet_info_t>() - 16usize];
    ["Alignment of _alpm_event_scriptlet_info_t"]
        [::std::mem::align_of::<_alpm_event_scriptlet_info_t>() - 8usize];
    ["Offset of field: _alpm_event_scriptlet_info_t::type_"]
        [::std::mem::offset_of!(_alpm_event_scriptlet_info_t, type_) - 0usize];
    ["Offset of field: _alpm_event_scriptlet_info_t::line"]
        [::std::mem::offset_of!(_alpm_event_scriptlet_info_t, line) - 8usize];
};
#[doc = " A scriptlet was ran."]
pub type alpm_event_scriptlet_info_t = _alpm_event_scriptlet_info_t;
#[doc = " A database is missing.\n\n The database is registered but has not been downloaded"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_database_missing_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Name of the database"]
    pub dbname: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_database_missing_t"]
        [::std::mem::size_of::<_alpm_event_database_missing_t>() - 16usize];
    ["Alignment of _alpm_event_database_missing_t"]
        [::std::mem::align_of::<_alpm_event_database_missing_t>() - 8usize];
    ["Offset of field: _alpm_event_database_missing_t::type_"]
        [::std::mem::offset_of!(_alpm_event_database_missing_t, type_) - 0usize];
    ["Offset of field: _alpm_event_database_missing_t::dbname"]
        [::std::mem::offset_of!(_alpm_event_database_missing_t, dbname) - 8usize];
};
#[doc = " A database is missing.\n\n The database is registered but has not been downloaded"]
pub type alpm_event_database_missing_t = _alpm_event_database_missing_t;
#[doc = " A package was downloaded."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pkgdownload_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Name of the file"]
    pub file: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_pkgdownload_t"]
        [::std::mem::size_of::<_alpm_event_pkgdownload_t>() - 16usize];
    ["Alignment of _alpm_event_pkgdownload_t"]
        [::std::mem::align_of::<_alpm_event_pkgdownload_t>() - 8usize];
    ["Offset of field: _alpm_event_pkgdownload_t::type_"]
        [::std::mem::offset_of!(_alpm_event_pkgdownload_t, type_) - 0usize];
    ["Offset of field: _alpm_event_pkgdownload_t::file"]
        [::std::mem::offset_of!(_alpm_event_pkgdownload_t, file) - 8usize];
};
#[doc = " A package was downloaded."]
pub type alpm_event_pkgdownload_t = _alpm_event_pkgdownload_t;
#[doc = " A pacnew file was created."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pacnew_created_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Whether the creation was result of a NoUpgrade or not"]
    pub from_noupgrade: ::std::os::raw::c_int,
    #[doc = " Old package"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " New Package"]
    pub newpkg: *mut alpm_pkg_t,
    #[doc = " Filename of the file without the .pacnew suffix"]
    pub file: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_pacnew_created_t"]
        [::std::mem::size_of::<_alpm_event_pacnew_created_t>() - 32usize];
    ["Alignment of _alpm_event_pacnew_created_t"]
        [::std::mem::align_of::<_alpm_event_pacnew_created_t>() - 8usize];
    ["Offset of field: _alpm_event_pacnew_created_t::type_"]
        [::std::mem::offset_of!(_alpm_event_pacnew_created_t, type_) - 0usize];
    ["Offset of field: _alpm_event_pacnew_created_t::from_noupgrade"]
        [::std::mem::offset_of!(_alpm_event_pacnew_created_t, from_noupgrade) - 4usize];
    ["Offset of field: _alpm_event_pacnew_created_t::oldpkg"]
        [::std::mem::offset_of!(_alpm_event_pacnew_created_t, oldpkg) - 8usize];
    ["Offset of field: _alpm_event_pacnew_created_t::newpkg"]
        [::std::mem::offset_of!(_alpm_event_pacnew_created_t, newpkg) - 16usize];
    ["Offset of field: _alpm_event_pacnew_created_t::file"]
        [::std::mem::offset_of!(_alpm_event_pacnew_created_t, file) - 24usize];
};
#[doc = " A pacnew file was created."]
pub type alpm_event_pacnew_created_t = _alpm_event_pacnew_created_t;
#[doc = " A pacsave file was created."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pacsave_created_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Old package"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " Filename of the file without the .pacsave suffix"]
    pub file: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_pacsave_created_t"]
        [::std::mem::size_of::<_alpm_event_pacsave_created_t>() - 24usize];
    ["Alignment of _alpm_event_pacsave_created_t"]
        [::std::mem::align_of::<_alpm_event_pacsave_created_t>() - 8usize];
    ["Offset of field: _alpm_event_pacsave_created_t::type_"]
        [::std::mem::offset_of!(_alpm_event_pacsave_created_t, type_) - 0usize];
    ["Offset of field: _alpm_event_pacsave_created_t::oldpkg"]
        [::std::mem::offset_of!(_alpm_event_pacsave_created_t, oldpkg) - 8usize];
    ["Offset of field: _alpm_event_pacsave_created_t::file"]
        [::std::mem::offset_of!(_alpm_event_pacsave_created_t, file) - 16usize];
};
#[doc = " A pacsave file was created."]
pub type alpm_event_pacsave_created_t = _alpm_event_pacsave_created_t;
#[repr(u32)]
#[doc = " Kind of hook."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_hook_when_t {
    ALPM_HOOK_PRE_TRANSACTION = 1,
    ALPM_HOOK_POST_TRANSACTION = 2,
}
#[doc = " Kind of hook."]
pub use self::_alpm_hook_when_t as alpm_hook_when_t;
#[doc = " pre/post transaction hooks are to be ran."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_hook_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Type of hook"]
    pub when: alpm_hook_when_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_hook_t"][::std::mem::size_of::<_alpm_event_hook_t>() - 8usize];
    ["Alignment of _alpm_event_hook_t"][::std::mem::align_of::<_alpm_event_hook_t>() - 4usize];
    ["Offset of field: _alpm_event_hook_t::type_"]
        [::std::mem::offset_of!(_alpm_event_hook_t, type_) - 0usize];
    ["Offset of field: _alpm_event_hook_t::when"]
        [::std::mem::offset_of!(_alpm_event_hook_t, when) - 4usize];
};
#[doc = " pre/post transaction hooks are to be ran."]
pub type alpm_event_hook_t = _alpm_event_hook_t;
#[doc = " A pre/post transaction hook was ran."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_hook_run_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Name of hook"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Description of hook to be outputted"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " position of hook being run"]
    pub position: usize,
    #[doc = " total hooks being run"]
    pub total: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_hook_run_t"][::std::mem::size_of::<_alpm_event_hook_run_t>() - 40usize];
    ["Alignment of _alpm_event_hook_run_t"]
        [::std::mem::align_of::<_alpm_event_hook_run_t>() - 8usize];
    ["Offset of field: _alpm_event_hook_run_t::type_"]
        [::std::mem::offset_of!(_alpm_event_hook_run_t, type_) - 0usize];
    ["Offset of field: _alpm_event_hook_run_t::name"]
        [::std::mem::offset_of!(_alpm_event_hook_run_t, name) - 8usize];
    ["Offset of field: _alpm_event_hook_run_t::desc"]
        [::std::mem::offset_of!(_alpm_event_hook_run_t, desc) - 16usize];
    ["Offset of field: _alpm_event_hook_run_t::position"]
        [::std::mem::offset_of!(_alpm_event_hook_run_t, position) - 24usize];
    ["Offset of field: _alpm_event_hook_run_t::total"]
        [::std::mem::offset_of!(_alpm_event_hook_run_t, total) - 32usize];
};
#[doc = " A pre/post transaction hook was ran."]
pub type alpm_event_hook_run_t = _alpm_event_hook_run_t;
#[doc = " Packages downloading about to start."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pkg_retrieve_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Number of packages to download"]
    pub num: usize,
    #[doc = " Total size of packages to download"]
    pub total_size: off_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_pkg_retrieve_t"]
        [::std::mem::size_of::<_alpm_event_pkg_retrieve_t>() - 24usize];
    ["Alignment of _alpm_event_pkg_retrieve_t"]
        [::std::mem::align_of::<_alpm_event_pkg_retrieve_t>() - 8usize];
    ["Offset of field: _alpm_event_pkg_retrieve_t::type_"]
        [::std::mem::offset_of!(_alpm_event_pkg_retrieve_t, type_) - 0usize];
    ["Offset of field: _alpm_event_pkg_retrieve_t::num"]
        [::std::mem::offset_of!(_alpm_event_pkg_retrieve_t, num) - 8usize];
    ["Offset of field: _alpm_event_pkg_retrieve_t::total_size"]
        [::std::mem::offset_of!(_alpm_event_pkg_retrieve_t, total_size) - 16usize];
};
#[doc = " Packages downloading about to start."]
pub type alpm_event_pkg_retrieve_t = _alpm_event_pkg_retrieve_t;
#[doc = " Events.\n This is a union passed to the callback that allows the frontend to know\n which type of event was triggered (via type). It is then possible to\n typecast the pointer to the right structure, or use the union field, in order\n to access event-specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _alpm_event_t {
    #[doc = " Type of event it's always safe to access this."]
    pub type_: alpm_event_type_t,
    #[doc = " The any event type. It's always safe to access this."]
    pub any: alpm_event_any_t,
    #[doc = " Package operation"]
    pub package_operation: alpm_event_package_operation_t,
    #[doc = " An optdept was remove"]
    pub optdep_removal: alpm_event_optdep_removal_t,
    #[doc = " A scriptlet was ran"]
    pub scriptlet_info: alpm_event_scriptlet_info_t,
    #[doc = " A database is missing"]
    pub database_missing: alpm_event_database_missing_t,
    #[doc = " A package was downloaded"]
    pub pkgdownload: alpm_event_pkgdownload_t,
    #[doc = " A pacnew file was created"]
    pub pacnew_created: alpm_event_pacnew_created_t,
    #[doc = " A pacsave file was created"]
    pub pacsave_created: alpm_event_pacsave_created_t,
    #[doc = " Pre/post transaction hooks are being ran"]
    pub hook: alpm_event_hook_t,
    #[doc = " A hook was ran"]
    pub hook_run: alpm_event_hook_run_t,
    #[doc = " Download packages"]
    pub pkg_retrieve: alpm_event_pkg_retrieve_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_event_t"][::std::mem::size_of::<_alpm_event_t>() - 40usize];
    ["Alignment of _alpm_event_t"][::std::mem::align_of::<_alpm_event_t>() - 8usize];
    ["Offset of field: _alpm_event_t::type_"]
        [::std::mem::offset_of!(_alpm_event_t, type_) - 0usize];
    ["Offset of field: _alpm_event_t::any"][::std::mem::offset_of!(_alpm_event_t, any) - 0usize];
    ["Offset of field: _alpm_event_t::package_operation"]
        [::std::mem::offset_of!(_alpm_event_t, package_operation) - 0usize];
    ["Offset of field: _alpm_event_t::optdep_removal"]
        [::std::mem::offset_of!(_alpm_event_t, optdep_removal) - 0usize];
    ["Offset of field: _alpm_event_t::scriptlet_info"]
        [::std::mem::offset_of!(_alpm_event_t, scriptlet_info) - 0usize];
    ["Offset of field: _alpm_event_t::database_missing"]
        [::std::mem::offset_of!(_alpm_event_t, database_missing) - 0usize];
    ["Offset of field: _alpm_event_t::pkgdownload"]
        [::std::mem::offset_of!(_alpm_event_t, pkgdownload) - 0usize];
    ["Offset of field: _alpm_event_t::pacnew_created"]
        [::std::mem::offset_of!(_alpm_event_t, pacnew_created) - 0usize];
    ["Offset of field: _alpm_event_t::pacsave_created"]
        [::std::mem::offset_of!(_alpm_event_t, pacsave_created) - 0usize];
    ["Offset of field: _alpm_event_t::hook"][::std::mem::offset_of!(_alpm_event_t, hook) - 0usize];
    ["Offset of field: _alpm_event_t::hook_run"]
        [::std::mem::offset_of!(_alpm_event_t, hook_run) - 0usize];
    ["Offset of field: _alpm_event_t::pkg_retrieve"]
        [::std::mem::offset_of!(_alpm_event_t, pkg_retrieve) - 0usize];
};
#[doc = " Events.\n This is a union passed to the callback that allows the frontend to know\n which type of event was triggered (via type). It is then possible to\n typecast the pointer to the right structure, or use the union field, in order\n to access event-specific data."]
pub type alpm_event_t = _alpm_event_t;
#[doc = " Event callback.\n\n Called when an event occurs\n @param ctx user-provided context\n @param event the event that occurred"]
pub type alpm_cb_event = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, event: *mut alpm_event_t),
>;
pub mod _alpm_question_type_t {
    #[doc = " Type of question.\n Unlike the events or progress enumerations, this enum has bitmask values\n so a frontend can use a bitmask map to supply preselected answers to the\n different types of questions."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Should target in ignorepkg be installed anyway?"]
    pub const ALPM_QUESTION_INSTALL_IGNOREPKG: Type = 1;
    #[doc = " Should a package be replaced?"]
    pub const ALPM_QUESTION_REPLACE_PKG: Type = 2;
    #[doc = " Should a conflicting package be removed?"]
    pub const ALPM_QUESTION_CONFLICT_PKG: Type = 4;
    #[doc = " Should a corrupted package be deleted?"]
    pub const ALPM_QUESTION_CORRUPTED_PKG: Type = 8;
    #[doc = " Should unresolvable targets be removed from the transaction?"]
    pub const ALPM_QUESTION_REMOVE_PKGS: Type = 16;
    #[doc = " Provider selection"]
    pub const ALPM_QUESTION_SELECT_PROVIDER: Type = 32;
    #[doc = " Should a key be imported?"]
    pub const ALPM_QUESTION_IMPORT_KEY: Type = 64;
}
#[doc = " Type of question.\n Unlike the events or progress enumerations, this enum has bitmask values\n so a frontend can use a bitmask map to supply preselected answers to the\n different types of questions."]
pub use self::_alpm_question_type_t::Type as alpm_question_type_t;
#[doc = " A question that can represent any other question."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_any_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer"]
    pub answer: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_any_t"][::std::mem::size_of::<_alpm_question_any_t>() - 8usize];
    ["Alignment of _alpm_question_any_t"][::std::mem::align_of::<_alpm_question_any_t>() - 4usize];
    ["Offset of field: _alpm_question_any_t::type_"]
        [::std::mem::offset_of!(_alpm_question_any_t, type_) - 0usize];
    ["Offset of field: _alpm_question_any_t::answer"]
        [::std::mem::offset_of!(_alpm_question_any_t, answer) - 4usize];
};
#[doc = " A question that can represent any other question."]
pub type alpm_question_any_t = _alpm_question_any_t;
#[doc = " Should target in ignorepkg be installed anyway?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_install_ignorepkg_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to install pkg anyway"]
    pub install: ::std::os::raw::c_int,
    #[doc = " The ignored package that we are deciding whether to install"]
    pub pkg: *mut alpm_pkg_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_install_ignorepkg_t"]
        [::std::mem::size_of::<_alpm_question_install_ignorepkg_t>() - 16usize];
    ["Alignment of _alpm_question_install_ignorepkg_t"]
        [::std::mem::align_of::<_alpm_question_install_ignorepkg_t>() - 8usize];
    ["Offset of field: _alpm_question_install_ignorepkg_t::type_"]
        [::std::mem::offset_of!(_alpm_question_install_ignorepkg_t, type_) - 0usize];
    ["Offset of field: _alpm_question_install_ignorepkg_t::install"]
        [::std::mem::offset_of!(_alpm_question_install_ignorepkg_t, install) - 4usize];
    ["Offset of field: _alpm_question_install_ignorepkg_t::pkg"]
        [::std::mem::offset_of!(_alpm_question_install_ignorepkg_t, pkg) - 8usize];
};
#[doc = " Should target in ignorepkg be installed anyway?"]
pub type alpm_question_install_ignorepkg_t = _alpm_question_install_ignorepkg_t;
#[doc = " Should a package be replaced?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_replace_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to replace oldpkg with newpkg"]
    pub replace: ::std::os::raw::c_int,
    #[doc = " Package to be replaced"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " Package to replace with."]
    pub newpkg: *mut alpm_pkg_t,
    #[doc = " DB of newpkg"]
    pub newdb: *mut alpm_db_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_replace_t"]
        [::std::mem::size_of::<_alpm_question_replace_t>() - 32usize];
    ["Alignment of _alpm_question_replace_t"]
        [::std::mem::align_of::<_alpm_question_replace_t>() - 8usize];
    ["Offset of field: _alpm_question_replace_t::type_"]
        [::std::mem::offset_of!(_alpm_question_replace_t, type_) - 0usize];
    ["Offset of field: _alpm_question_replace_t::replace"]
        [::std::mem::offset_of!(_alpm_question_replace_t, replace) - 4usize];
    ["Offset of field: _alpm_question_replace_t::oldpkg"]
        [::std::mem::offset_of!(_alpm_question_replace_t, oldpkg) - 8usize];
    ["Offset of field: _alpm_question_replace_t::newpkg"]
        [::std::mem::offset_of!(_alpm_question_replace_t, newpkg) - 16usize];
    ["Offset of field: _alpm_question_replace_t::newdb"]
        [::std::mem::offset_of!(_alpm_question_replace_t, newdb) - 24usize];
};
#[doc = " Should a package be replaced?"]
pub type alpm_question_replace_t = _alpm_question_replace_t;
#[doc = " Should a conflicting package be removed?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_conflict_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to remove conflict->package2"]
    pub remove: ::std::os::raw::c_int,
    #[doc = " Conflict info"]
    pub conflict: *mut alpm_conflict_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_conflict_t"]
        [::std::mem::size_of::<_alpm_question_conflict_t>() - 16usize];
    ["Alignment of _alpm_question_conflict_t"]
        [::std::mem::align_of::<_alpm_question_conflict_t>() - 8usize];
    ["Offset of field: _alpm_question_conflict_t::type_"]
        [::std::mem::offset_of!(_alpm_question_conflict_t, type_) - 0usize];
    ["Offset of field: _alpm_question_conflict_t::remove"]
        [::std::mem::offset_of!(_alpm_question_conflict_t, remove) - 4usize];
    ["Offset of field: _alpm_question_conflict_t::conflict"]
        [::std::mem::offset_of!(_alpm_question_conflict_t, conflict) - 8usize];
};
#[doc = " Should a conflicting package be removed?"]
pub type alpm_question_conflict_t = _alpm_question_conflict_t;
#[doc = " Should a corrupted package be deleted?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_corrupted_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to remove filepath"]
    pub remove: ::std::os::raw::c_int,
    #[doc = " File to remove"]
    pub filepath: *const ::std::os::raw::c_char,
    #[doc = " Error code indicating the reason for package invalidity"]
    pub reason: alpm_errno_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_corrupted_t"]
        [::std::mem::size_of::<_alpm_question_corrupted_t>() - 24usize];
    ["Alignment of _alpm_question_corrupted_t"]
        [::std::mem::align_of::<_alpm_question_corrupted_t>() - 8usize];
    ["Offset of field: _alpm_question_corrupted_t::type_"]
        [::std::mem::offset_of!(_alpm_question_corrupted_t, type_) - 0usize];
    ["Offset of field: _alpm_question_corrupted_t::remove"]
        [::std::mem::offset_of!(_alpm_question_corrupted_t, remove) - 4usize];
    ["Offset of field: _alpm_question_corrupted_t::filepath"]
        [::std::mem::offset_of!(_alpm_question_corrupted_t, filepath) - 8usize];
    ["Offset of field: _alpm_question_corrupted_t::reason"]
        [::std::mem::offset_of!(_alpm_question_corrupted_t, reason) - 16usize];
};
#[doc = " Should a corrupted package be deleted?"]
pub type alpm_question_corrupted_t = _alpm_question_corrupted_t;
#[doc = " Should unresolvable targets be removed from the transaction?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_remove_pkgs_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to skip packages"]
    pub skip: ::std::os::raw::c_int,
    #[doc = " List of alpm_pkg_t* with unresolved dependencies"]
    pub packages: *mut alpm_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_remove_pkgs_t"]
        [::std::mem::size_of::<_alpm_question_remove_pkgs_t>() - 16usize];
    ["Alignment of _alpm_question_remove_pkgs_t"]
        [::std::mem::align_of::<_alpm_question_remove_pkgs_t>() - 8usize];
    ["Offset of field: _alpm_question_remove_pkgs_t::type_"]
        [::std::mem::offset_of!(_alpm_question_remove_pkgs_t, type_) - 0usize];
    ["Offset of field: _alpm_question_remove_pkgs_t::skip"]
        [::std::mem::offset_of!(_alpm_question_remove_pkgs_t, skip) - 4usize];
    ["Offset of field: _alpm_question_remove_pkgs_t::packages"]
        [::std::mem::offset_of!(_alpm_question_remove_pkgs_t, packages) - 8usize];
};
#[doc = " Should unresolvable targets be removed from the transaction?"]
pub type alpm_question_remove_pkgs_t = _alpm_question_remove_pkgs_t;
#[doc = " Provider selection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_select_provider_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: which provider to use (index from providers)"]
    pub use_index: ::std::os::raw::c_int,
    #[doc = " List of alpm_pkg_t* as possible providers"]
    pub providers: *mut alpm_list_t,
    #[doc = " What providers provide for"]
    pub depend: *mut alpm_depend_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_select_provider_t"]
        [::std::mem::size_of::<_alpm_question_select_provider_t>() - 24usize];
    ["Alignment of _alpm_question_select_provider_t"]
        [::std::mem::align_of::<_alpm_question_select_provider_t>() - 8usize];
    ["Offset of field: _alpm_question_select_provider_t::type_"]
        [::std::mem::offset_of!(_alpm_question_select_provider_t, type_) - 0usize];
    ["Offset of field: _alpm_question_select_provider_t::use_index"]
        [::std::mem::offset_of!(_alpm_question_select_provider_t, use_index) - 4usize];
    ["Offset of field: _alpm_question_select_provider_t::providers"]
        [::std::mem::offset_of!(_alpm_question_select_provider_t, providers) - 8usize];
    ["Offset of field: _alpm_question_select_provider_t::depend"]
        [::std::mem::offset_of!(_alpm_question_select_provider_t, depend) - 16usize];
};
#[doc = " Provider selection"]
pub type alpm_question_select_provider_t = _alpm_question_select_provider_t;
#[doc = " Should a key be imported?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_import_key_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to import key"]
    pub import: ::std::os::raw::c_int,
    #[doc = " UID of the key to import"]
    pub uid: *const ::std::os::raw::c_char,
    #[doc = " Fingerprint the key to import"]
    pub fingerprint: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_import_key_t"]
        [::std::mem::size_of::<_alpm_question_import_key_t>() - 24usize];
    ["Alignment of _alpm_question_import_key_t"]
        [::std::mem::align_of::<_alpm_question_import_key_t>() - 8usize];
    ["Offset of field: _alpm_question_import_key_t::type_"]
        [::std::mem::offset_of!(_alpm_question_import_key_t, type_) - 0usize];
    ["Offset of field: _alpm_question_import_key_t::import"]
        [::std::mem::offset_of!(_alpm_question_import_key_t, import) - 4usize];
    ["Offset of field: _alpm_question_import_key_t::uid"]
        [::std::mem::offset_of!(_alpm_question_import_key_t, uid) - 8usize];
    ["Offset of field: _alpm_question_import_key_t::fingerprint"]
        [::std::mem::offset_of!(_alpm_question_import_key_t, fingerprint) - 16usize];
};
#[doc = " Should a key be imported?"]
pub type alpm_question_import_key_t = _alpm_question_import_key_t;
#[doc = " Questions.\n This is an union passed to the callback that allows the frontend to know\n which type of question was triggered (via type). It is then possible to\n typecast the pointer to the right structure, or use the union field, in order\n to access question-specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _alpm_question_t {
    #[doc = " The type of question. It's always safe to access this."]
    pub type_: alpm_question_type_t,
    #[doc = " A question that can represent any question.\n It's always safe to access this."]
    pub any: alpm_question_any_t,
    #[doc = " Should target in ignorepkg be installed anyway?"]
    pub install_ignorepkg: alpm_question_install_ignorepkg_t,
    #[doc = " Should a package be replaced?"]
    pub replace: alpm_question_replace_t,
    #[doc = " Should a conflicting package be removed?"]
    pub conflict: alpm_question_conflict_t,
    #[doc = " Should a corrupted package be deleted?"]
    pub corrupted: alpm_question_corrupted_t,
    #[doc = " Should unresolvable targets be removed from the transaction?"]
    pub remove_pkgs: alpm_question_remove_pkgs_t,
    #[doc = " Provider selection"]
    pub select_provider: alpm_question_select_provider_t,
    #[doc = " Should a key be imported?"]
    pub import_key: alpm_question_import_key_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_question_t"][::std::mem::size_of::<_alpm_question_t>() - 32usize];
    ["Alignment of _alpm_question_t"][::std::mem::align_of::<_alpm_question_t>() - 8usize];
    ["Offset of field: _alpm_question_t::type_"]
        [::std::mem::offset_of!(_alpm_question_t, type_) - 0usize];
    ["Offset of field: _alpm_question_t::any"]
        [::std::mem::offset_of!(_alpm_question_t, any) - 0usize];
    ["Offset of field: _alpm_question_t::install_ignorepkg"]
        [::std::mem::offset_of!(_alpm_question_t, install_ignorepkg) - 0usize];
    ["Offset of field: _alpm_question_t::replace"]
        [::std::mem::offset_of!(_alpm_question_t, replace) - 0usize];
    ["Offset of field: _alpm_question_t::conflict"]
        [::std::mem::offset_of!(_alpm_question_t, conflict) - 0usize];
    ["Offset of field: _alpm_question_t::corrupted"]
        [::std::mem::offset_of!(_alpm_question_t, corrupted) - 0usize];
    ["Offset of field: _alpm_question_t::remove_pkgs"]
        [::std::mem::offset_of!(_alpm_question_t, remove_pkgs) - 0usize];
    ["Offset of field: _alpm_question_t::select_provider"]
        [::std::mem::offset_of!(_alpm_question_t, select_provider) - 0usize];
    ["Offset of field: _alpm_question_t::import_key"]
        [::std::mem::offset_of!(_alpm_question_t, import_key) - 0usize];
};
#[doc = " Questions.\n This is an union passed to the callback that allows the frontend to know\n which type of question was triggered (via type). It is then possible to\n typecast the pointer to the right structure, or use the union field, in order\n to access question-specific data."]
pub type alpm_question_t = _alpm_question_t;
#[doc = " Question callback.\n\n This callback allows user to give input and decide what to do during certain events\n @param ctx user-provided context\n @param question the question being asked."]
pub type alpm_cb_question = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, question: *mut alpm_question_t),
>;
#[repr(u32)]
#[doc = " An enum over different kinds of progress alerts."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_progress_t {
    #[doc = " Package install"]
    ALPM_PROGRESS_ADD_START = 0,
    #[doc = " Package upgrade"]
    ALPM_PROGRESS_UPGRADE_START = 1,
    #[doc = " Package downgrade"]
    ALPM_PROGRESS_DOWNGRADE_START = 2,
    #[doc = " Package reinstall"]
    ALPM_PROGRESS_REINSTALL_START = 3,
    #[doc = " Package removal"]
    ALPM_PROGRESS_REMOVE_START = 4,
    #[doc = " Conflict checking"]
    ALPM_PROGRESS_CONFLICTS_START = 5,
    #[doc = " Diskspace checking"]
    ALPM_PROGRESS_DISKSPACE_START = 6,
    #[doc = " Package Integrity checking"]
    ALPM_PROGRESS_INTEGRITY_START = 7,
    #[doc = " Loading packages from disk"]
    ALPM_PROGRESS_LOAD_START = 8,
    #[doc = " Checking signatures of packages"]
    ALPM_PROGRESS_KEYRING_START = 9,
}
#[doc = " An enum over different kinds of progress alerts."]
pub use self::_alpm_progress_t as alpm_progress_t;
#[doc = " Progress callback\n\n Alert the front end about the progress of certain events.\n Allows the implementation of loading bars for events that\n make take a while to complete.\n @param ctx user-provided context\n @param progress the kind of event that is progressing\n @param pkg for package operations, the name of the package being operated on\n @param percent the percent completion of the action\n @param howmany the total amount of items in the action\n @param current the current amount of items completed\n/\n/** Progress callback"]
pub type alpm_cb_progress = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        progress: alpm_progress_t,
        pkg: *const ::std::os::raw::c_char,
        percent: ::std::os::raw::c_int,
        howmany: usize,
        current: usize,
    ),
>;
#[repr(u32)]
#[doc = " File download events.\n These events are reported by ALPM via download callback."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_download_event_type_t {
    #[doc = " A download was started"]
    ALPM_DOWNLOAD_INIT = 0,
    #[doc = " A download made progress"]
    ALPM_DOWNLOAD_PROGRESS = 1,
    #[doc = " Download will be retried"]
    ALPM_DOWNLOAD_RETRY = 2,
    #[doc = " A download completed"]
    ALPM_DOWNLOAD_COMPLETED = 3,
}
#[doc = " File download events.\n These events are reported by ALPM via download callback."]
pub use self::_alpm_download_event_type_t as alpm_download_event_type_t;
#[doc = " Context struct for when a download starts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_init_t {
    #[doc = " whether this file is optional and thus the errors could be ignored"]
    pub optional: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_download_event_init_t"]
        [::std::mem::size_of::<_alpm_download_event_init_t>() - 4usize];
    ["Alignment of _alpm_download_event_init_t"]
        [::std::mem::align_of::<_alpm_download_event_init_t>() - 4usize];
    ["Offset of field: _alpm_download_event_init_t::optional"]
        [::std::mem::offset_of!(_alpm_download_event_init_t, optional) - 0usize];
};
#[doc = " Context struct for when a download starts."]
pub type alpm_download_event_init_t = _alpm_download_event_init_t;
#[doc = " Context struct for when a download progresses."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_progress_t {
    #[doc = " Amount of data downloaded"]
    pub downloaded: off_t,
    #[doc = " Total amount need to be downloaded"]
    pub total: off_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_download_event_progress_t"]
        [::std::mem::size_of::<_alpm_download_event_progress_t>() - 16usize];
    ["Alignment of _alpm_download_event_progress_t"]
        [::std::mem::align_of::<_alpm_download_event_progress_t>() - 8usize];
    ["Offset of field: _alpm_download_event_progress_t::downloaded"]
        [::std::mem::offset_of!(_alpm_download_event_progress_t, downloaded) - 0usize];
    ["Offset of field: _alpm_download_event_progress_t::total"]
        [::std::mem::offset_of!(_alpm_download_event_progress_t, total) - 8usize];
};
#[doc = " Context struct for when a download progresses."]
pub type alpm_download_event_progress_t = _alpm_download_event_progress_t;
#[doc = " Context struct for when a download retries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_retry_t {
    #[doc = " If the download will resume or start over"]
    pub resume: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_download_event_retry_t"]
        [::std::mem::size_of::<_alpm_download_event_retry_t>() - 4usize];
    ["Alignment of _alpm_download_event_retry_t"]
        [::std::mem::align_of::<_alpm_download_event_retry_t>() - 4usize];
    ["Offset of field: _alpm_download_event_retry_t::resume"]
        [::std::mem::offset_of!(_alpm_download_event_retry_t, resume) - 0usize];
};
#[doc = " Context struct for when a download retries."]
pub type alpm_download_event_retry_t = _alpm_download_event_retry_t;
#[doc = " Context struct for when a download completes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_completed_t {
    #[doc = " Total bytes in file"]
    pub total: off_t,
    #[doc = " download result code:\n    0 - download completed successfully\n    1 - the file is up-to-date\n   -1 - error"]
    pub result: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _alpm_download_event_completed_t"]
        [::std::mem::size_of::<_alpm_download_event_completed_t>() - 16usize];
    ["Alignment of _alpm_download_event_completed_t"]
        [::std::mem::align_of::<_alpm_download_event_completed_t>() - 8usize];
    ["Offset of field: _alpm_download_event_completed_t::total"]
        [::std::mem::offset_of!(_alpm_download_event_completed_t, total) - 0usize];
    ["Offset of field: _alpm_download_event_completed_t::result"]
        [::std::mem::offset_of!(_alpm_download_event_completed_t, result) - 8usize];
};
#[doc = " Context struct for when a download completes."]
pub type alpm_download_event_completed_t = _alpm_download_event_completed_t;
#[doc = " Type of download progress callbacks.\n @param ctx user-provided context\n @param filename the name of the file being downloaded\n @param event the event type\n @param data the event data of type alpm_download_event_*_t"]
pub type alpm_cb_download = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        event: alpm_download_event_type_t,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A callback for downloading files\n @param ctx user-provided context\n @param url the URL of the file to be downloaded\n @param localpath the directory to which the file should be downloaded\n @param force whether to force an update, even if the file is the same\n @return 0 on success, 1 if the file exists and is identical, -1 on\n error."]
pub type alpm_cb_fetch = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        url: *const ::std::os::raw::c_char,
        localpath: *const ::std::os::raw::c_char,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Get the database of locally installed packages.\n The returned pointer points to an internal structure\n of libalpm which should only be manipulated through\n libalpm functions.\n @return a reference to the local database"]
    pub fn alpm_get_localdb(handle: *mut alpm_handle_t) -> *mut alpm_db_t;
}
extern "C" {
    #[doc = " Get the list of sync databases.\n Returns a list of alpm_db_t structures, one for each registered\n sync database.\n\n @param handle the context handle\n @return a reference to an internal list of alpm_db_t structures"]
    pub fn alpm_get_syncdbs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Register a sync database of packages.\n Databases can not be registered when there is an active transaction.\n\n @param handle the context handle\n @param treename the name of the sync repository\n @param level what level of signature checking to perform on the\n database; note that this must be a '.sig' file type verification\n @return an alpm_db_t* on success (the value), NULL on error"]
    pub fn alpm_register_syncdb(
        handle: *mut alpm_handle_t,
        treename: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> *mut alpm_db_t;
}
extern "C" {
    #[doc = " Unregister all package databases.\n Databases can not be unregistered while there is an active transaction.\n\n @param handle the context handle\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_unregister_all_syncdbs(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister a package database.\n Databases can not be unregistered when there is an active transaction.\n\n @param db pointer to the package database to unregister\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_unregister(db: *mut alpm_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the handle of a package database.\n @param db pointer to the package database\n @return the alpm handle that the package database belongs to"]
    pub fn alpm_db_get_handle(db: *mut alpm_db_t) -> *mut alpm_handle_t;
}
extern "C" {
    #[doc = " Get the name of a package database.\n @param db pointer to the package database\n @return the name of the package database, NULL on error"]
    pub fn alpm_db_get_name(db: *const alpm_db_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the signature verification level for a database.\n Will return the default verification level if this database is set up\n with ALPM_SIG_USE_DEFAULT.\n @param db pointer to the package database\n @return the signature verification level"]
    pub fn alpm_db_get_siglevel(db: *mut alpm_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the validity of a database.\n This is most useful for sync databases and verifying signature status.\n If invalid, the handle error code will be set accordingly.\n @param db pointer to the package database\n @return 0 if valid, -1 if invalid (pm_errno is set accordingly)"]
    pub fn alpm_db_get_valid(db: *mut alpm_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the list of servers assigned to this db.\n @param db pointer to the database to get the servers from\n @return a char* list of servers"]
    pub fn alpm_db_get_servers(db: *const alpm_db_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Sets the list of servers for the database to use.\n @param db the database to set the servers. The list will be duped and\n the original will still need to be freed by the caller.\n @param servers a char* list of servers."]
    pub fn alpm_db_set_servers(
        db: *mut alpm_db_t,
        servers: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a download server to a database.\n @param db database pointer\n @param url url of the server\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_add_server(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a download server from a database.\n @param db database pointer\n @param url url of the server\n @return 0 on success, 1 on server not present,\n -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_remove_server(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the list of cache servers assigned to this db.\n @param db pointer to the database to get the servers from\n @return a char* list of servers"]
    pub fn alpm_db_get_cache_servers(db: *const alpm_db_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Sets the list of cache servers for the database to use.\n @param db the database to set the servers. The list will be duped and\n the original will still need to be freed by the caller.\n @param servers a char* list of servers."]
    pub fn alpm_db_set_cache_servers(
        db: *mut alpm_db_t,
        servers: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a download cache server to a database.\n @param db database pointer\n @param url url of the server\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_add_cache_server(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a download cache server from a database.\n @param db database pointer\n @param url url of the server\n @return 0 on success, 1 on server not present,\n -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_remove_cache_server(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update package databases.\n\n An update of the package databases in the list \\a dbs will be attempted.\n Unless \\a force is true, the update will only be performed if the remote\n databases were modified since the last update.\n\n This operation requires a database lock, and will return an applicable error\n if the lock could not be obtained.\n\n Example:\n @code\n alpm_list_t *dbs = alpm_get_syncdbs(config->handle);\n ret = alpm_db_update(config->handle, dbs, force);\n if(ret < 0) {\n     pm_printf(ALPM_LOG_ERROR, _(\"failed to synchronize all databases (%s)\\n\"),\n         alpm_strerror(alpm_errno(config->handle)));\n }\n @endcode\n\n @note After a successful update, the \\link alpm_db_get_pkgcache()\n package cache \\endlink will be invalidated\n @param handle the context handle\n @param dbs list of package databases to update\n @param force if true, then forces the update, otherwise update only in case\n the databases aren't up to date\n @return 0 on success, -1 on error (pm_errno is set accordingly),\n 1 if all databases are up to to date"]
    pub fn alpm_db_update(
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a package entry from a package database.\n Looking up a package is O(1) and will be significantly faster than\n iterating over the pkgcahe.\n @param db pointer to the package database to get the package from\n @param name of the package\n @return the package entry on success, NULL on error"]
    pub fn alpm_db_get_pkg(
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    #[doc = " Get the package cache of a package database.\n This is a list of all packages the db contains.\n @param db pointer to the package database to get the package from\n @return the list of packages on success, NULL on error"]
    pub fn alpm_db_get_pkgcache(db: *mut alpm_db_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Get a group entry from a package database.\n Looking up a group is O(1) and will be significantly faster than\n iterating over the groupcahe.\n @param db pointer to the package database to get the group from\n @param name of the group\n @return the groups entry on success, NULL on error"]
    pub fn alpm_db_get_group(
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_group_t;
}
extern "C" {
    #[doc = " Get the group cache of a package database.\n @param db pointer to the package database to get the group from\n @return the list of groups on success, NULL on error"]
    pub fn alpm_db_get_groupcache(db: *mut alpm_db_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Searches a database with regular expressions.\n @param db pointer to the package database to search in\n @param needles a list of regular expressions to search for\n @param ret pointer to list for storing packages matching all\n regular expressions - must point to an empty (NULL) alpm_list_t *.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_search(
        db: *mut alpm_db_t,
        needles: *const alpm_list_t,
        ret: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
pub mod _alpm_db_usage_t {
    #[doc = " The usage level of a database."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Enable refreshes for this database"]
    pub const ALPM_DB_USAGE_SYNC: Type = 1;
    #[doc = " Enable search for this database"]
    pub const ALPM_DB_USAGE_SEARCH: Type = 2;
    #[doc = " Enable installing packages from this database"]
    pub const ALPM_DB_USAGE_INSTALL: Type = 4;
    #[doc = " Enable sysupgrades with this database"]
    pub const ALPM_DB_USAGE_UPGRADE: Type = 8;
    #[doc = " Enable all usage levels"]
    pub const ALPM_DB_USAGE_ALL: Type = 15;
}
#[doc = " The usage level of a database."]
pub use self::_alpm_db_usage_t::Type as alpm_db_usage_t;
extern "C" {
    #[doc = " Sets the usage of a database.\n @param db pointer to the package database to set the status for\n @param usage a bitmask of alpm_db_usage_t values\n @return 0 on success, or -1 on error"]
    pub fn alpm_db_set_usage(
        db: *mut alpm_db_t,
        usage: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the usage of a database.\n @param db pointer to the package database to get the status of\n @param usage pointer to an alpm_db_usage_t to store db's status\n @return 0 on success, or -1 on error"]
    pub fn alpm_db_get_usage(
        db: *mut alpm_db_t,
        usage: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub mod _alpm_loglevel_t {
    #[doc = " Logging Levels"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Error"]
    pub const ALPM_LOG_ERROR: Type = 1;
    #[doc = " Warning"]
    pub const ALPM_LOG_WARNING: Type = 2;
    #[doc = " Debug"]
    pub const ALPM_LOG_DEBUG: Type = 4;
    #[doc = " Function"]
    pub const ALPM_LOG_FUNCTION: Type = 8;
}
#[doc = " Logging Levels"]
pub use self::_alpm_loglevel_t::Type as alpm_loglevel_t;
#[doc = " The callback type for logging.\n\n libalpm will call this function whenever something is to be logged.\n many libalpm will produce log output. Additionally any calls to \\link alpm_logaction\n \\endlink will also call this callback.\n @param ctx user-provided context\n @param level the currently set loglevel\n @param fmt the printf like format string\n @param args printf like arguments"]
pub type alpm_cb_log = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        level: alpm_loglevel_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ),
>;
extern "C" {
    #[doc = " A printf-like function for logging.\n @param handle the context handle\n @param prefix caller-specific prefix for the log\n @param fmt output format\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_logaction(
        handle: *mut alpm_handle_t,
        prefix: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used for logging.\n @param handle the context handle\n @return the currently set log callback"]
    pub fn alpm_option_get_logcb(handle: *mut alpm_handle_t) -> alpm_cb_log;
}
extern "C" {
    #[doc = " Returns the callback used for logging.\n @param handle the context handle\n @return the currently set log callback context"]
    pub fn alpm_option_get_logcb_ctx(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the callback used for logging.\n @param handle the context handle\n @param cb the cb to use\n @param ctx user-provided context to pass to cb\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_logcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_log,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used to report download progress.\n @param handle the context handle\n @return the currently set download callback"]
    pub fn alpm_option_get_dlcb(handle: *mut alpm_handle_t) -> alpm_cb_download;
}
extern "C" {
    #[doc = " Returns the callback used to report download progress.\n @param handle the context handle\n @return the currently set download callback context"]
    pub fn alpm_option_get_dlcb_ctx(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the callback used to report download progress.\n @param handle the context handle\n @param cb the cb to use\n @param ctx user-provided context to pass to cb\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_dlcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_download,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the downloading callback.\n @param handle the context handle\n @return the currently set fetch callback"]
    pub fn alpm_option_get_fetchcb(handle: *mut alpm_handle_t) -> alpm_cb_fetch;
}
extern "C" {
    #[doc = " Returns the downloading callback.\n @param handle the context handle\n @return the currently set fetch callback context"]
    pub fn alpm_option_get_fetchcb_ctx(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the downloading callback.\n @param handle the context handle\n @param cb the cb to use\n @param ctx user-provided context to pass to cb\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_fetchcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_fetch,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used for events.\n @param handle the context handle\n @return the currently set event callback"]
    pub fn alpm_option_get_eventcb(handle: *mut alpm_handle_t) -> alpm_cb_event;
}
extern "C" {
    #[doc = " Returns the callback used for events.\n @param handle the context handle\n @return the currently set event callback context"]
    pub fn alpm_option_get_eventcb_ctx(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the callback used for events.\n @param handle the context handle\n @param cb the cb to use\n @param ctx user-provided context to pass to cb\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_eventcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_event,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used for questions.\n @param handle the context handle\n @return the currently set question callback"]
    pub fn alpm_option_get_questioncb(handle: *mut alpm_handle_t) -> alpm_cb_question;
}
extern "C" {
    #[doc = " Returns the callback used for questions.\n @param handle the context handle\n @return the currently set question callback context"]
    pub fn alpm_option_get_questioncb_ctx(
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the callback used for questions.\n @param handle the context handle\n @param cb the cb to use\n @param ctx user-provided context to pass to cb\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_questioncb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_question,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the callback used for operation progress.\n @param handle the context handle\n @return the currently set progress callback"]
    pub fn alpm_option_get_progresscb(handle: *mut alpm_handle_t) -> alpm_cb_progress;
}
extern "C" {
    #[doc = "Returns the callback used for operation progress.\n @param handle the context handle\n @return the currently set progress callback context"]
    pub fn alpm_option_get_progresscb_ctx(
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets the callback used for operation progress.\n @param handle the context handle\n @param cb the cb to use\n @param ctx user-provided context to pass to cb\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_progresscb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_progress,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the root path. Read-only.\n @param handle the context handle"]
    pub fn alpm_option_get_root(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the path to the database directory. Read-only.\n @param handle the context handle"]
    pub fn alpm_option_get_dbpath(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the database lock file. Read-only.\n This is the name that the lockfile would have. It does not\n matter if the lockfile actually exists on disk.\n @param handle the context handle"]
    pub fn alpm_option_get_lockfile(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the currently configured cachedirs,\n @param handle the context handle\n @return a char* list of cache directories"]
    pub fn alpm_option_get_cachedirs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Sets the cachedirs.\n @param handle the context handle\n @param cachedirs a char* list of cachdirs. The list will be duped and\n the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_cachedirs(
        handle: *mut alpm_handle_t,
        cachedirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append a cachedir to the configured cachedirs.\n @param handle the context handle\n @param cachedir the cachedir to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_cachedir(
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a cachedir from the configured cachedirs.\n @param handle the context handle\n @param cachedir the cachedir to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_cachedir(
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the currently configured hookdirs,\n @param handle the context handle\n @return a char* list of hook directories"]
    pub fn alpm_option_get_hookdirs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Sets the hookdirs.\n @param handle the context handle\n @param hookdirs a char* list of hookdirs. The list will be duped and\n the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_hookdirs(
        handle: *mut alpm_handle_t,
        hookdirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append a hookdir to the configured hookdirs.\n @param handle the context handle\n @param hookdir the hookdir to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_hookdir(
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a hookdir from the configured hookdirs.\n @param handle the context handle\n @param hookdir the hookdir to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_hookdir(
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the currently configured overwritable files,\n @param handle the context handle\n @return a char* list of overwritable file globs"]
    pub fn alpm_option_get_overwrite_files(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Sets the overwritable files.\n @param handle the context handle\n @param globs a char* list of overwritable file globs. The list will be duped and\n the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_overwrite_files(
        handle: *mut alpm_handle_t,
        globs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append an overwritable file to the configured overwritable files.\n @param handle the context handle\n @param glob the file glob to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_overwrite_file(
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a file glob from the configured overwritable files globs.\n @note The overwritable file list contains a list of globs. The glob to\n remove must exactly match the entry to remove. There is no glob expansion.\n @param handle the context handle\n @param glob the file glob to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_overwrite_file(
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the filepath to the currently set logfile.\n @param handle the context handle\n @return the path to the logfile"]
    pub fn alpm_option_get_logfile(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the logfile path.\n @param handle the context handle\n @param logfile path to the new location of the logfile\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_logfile(
        handle: *mut alpm_handle_t,
        logfile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the path to libalpm's GnuPG home directory.\n @param handle the context handle\n @return the path to libalpms's GnuPG home directory"]
    pub fn alpm_option_get_gpgdir(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the path to libalpm's GnuPG home directory.\n @param handle the context handle\n @param gpgdir the gpgdir to set"]
    pub fn alpm_option_set_gpgdir(
        handle: *mut alpm_handle_t,
        gpgdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the user to switch to for sensitive operations.\n @return the user name"]
    pub fn alpm_option_get_sandboxuser(handle: *mut alpm_handle_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the user to switch to for sensitive operations.\n @param handle the context handle\n @param sandboxuser the user to set"]
    pub fn alpm_option_set_sandboxuser(
        handle: *mut alpm_handle_t,
        sandboxuser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether to use syslog (0 is FALSE, TRUE otherwise).\n @param handle the context handle\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_get_usesyslog(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets whether to use syslog (0 is FALSE, TRUE otherwise).\n @param handle the context handle\n @param usesyslog whether to use the syslog (0 is FALSE, TRUE otherwise)"]
    pub fn alpm_option_set_usesyslog(
        handle: *mut alpm_handle_t,
        usesyslog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the list of no-upgrade files\n @param handle the context handle\n @return the char* list of no-upgrade files"]
    pub fn alpm_option_get_noupgrades(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Add a file to the no-upgrade list\n @param handle the context handle\n @param path the path to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the list of no-upgrade files\n @param handle the context handle\n @param noupgrade a char* list of file to not upgrade.\n The list will be duped and the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_noupgrades(
        handle: *mut alpm_handle_t,
        noupgrade: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove an entry from the no-upgrade list\n @param handle the context handle\n @param path the path to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if a path matches any of the globs in the no-upgrade list\n @param handle the context handle\n @param path the path to test\n @return 0 is the path matches a glob, negative if there is no match and\n positive is the  match was inverted"]
    pub fn alpm_option_match_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the list of no-extract files\n @param handle the context handle\n @return the char* list of no-extract files"]
    pub fn alpm_option_get_noextracts(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Add a file to the no-extract list\n @param handle the context handle\n @param path the path to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_noextract(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the list of no-extract files\n @param handle the context handle\n @param noextract a char* list of file to not extract.\n The list will be duped and the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_noextracts(
        handle: *mut alpm_handle_t,
        noextract: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove an entry from the no-extract list\n @param handle the context handle\n @param path the path to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_noextract(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if a path matches any of the globs in the no-extract list\n @param handle the context handle\n @param path the path to test\n @return 0 is the path matches a glob, negative if there is no match and\n positive is the  match was inverted"]
    pub fn alpm_option_match_noextract(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the list of ignored packages\n @param handle the context handle\n @return the char* list of ignored packages"]
    pub fn alpm_option_get_ignorepkgs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Add a file to the ignored package list\n @param handle the context handle\n @param pkg the package to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_ignorepkg(
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the list of packages to ignore\n @param handle the context handle\n @param ignorepkgs a char* list of packages to ignore\n The list will be duped and the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_ignorepkgs(
        handle: *mut alpm_handle_t,
        ignorepkgs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove an entry from the ignorepkg list\n @param handle the context handle\n @param pkg the package to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_ignorepkg(
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the list of ignored groups\n @param handle the context handle\n @return the char* list of ignored groups"]
    pub fn alpm_option_get_ignoregroups(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Add a file to the ignored group list\n @param handle the context handle\n @param grp the group to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_ignoregroup(
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the list of groups to ignore\n @param handle the context handle\n @param ignoregrps a char* list of groups to ignore\n The list will be duped and the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_ignoregroups(
        handle: *mut alpm_handle_t,
        ignoregrps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove an entry from the ignoregroup list\n @param handle the context handle\n @param grp the group to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_ignoregroup(
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the list of dependencies that are assumed to be met\n @param handle the context handle\n @return a list of alpm_depend_t*"]
    pub fn alpm_option_get_assumeinstalled(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Add a depend to the assumed installed list\n @param handle the context handle\n @param dep the dependency to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_add_assumeinstalled(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the list of dependencies that are assumed to be met\n @param handle the context handle\n @param deps a list of *alpm_depend_t\n The list will be duped and the original will still need to be freed by the caller.\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_assumeinstalled(
        handle: *mut alpm_handle_t,
        deps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove an entry from the assume installed list\n @param handle the context handle\n @param dep the dep to remove\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_remove_assumeinstalled(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the allowed package architecture.\n @param handle the context handle\n @return the configured package architectures"]
    pub fn alpm_option_get_architectures(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Adds an allowed package architecture.\n @param handle the context handle\n @param arch the architecture to set"]
    pub fn alpm_option_add_architecture(
        handle: *mut alpm_handle_t,
        arch: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the allowed package architecture.\n @param handle the context handle\n @param arches the architecture to set"]
    pub fn alpm_option_set_architectures(
        handle: *mut alpm_handle_t,
        arches: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes an allowed package architecture.\n @param handle the context handle\n @param arch the architecture to remove"]
    pub fn alpm_option_remove_architecture(
        handle: *mut alpm_handle_t,
        arch: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get whether or not checking for free space before installing packages is enabled.\n @param handle the context handle\n @return 0 if disabled, 1 if enabled"]
    pub fn alpm_option_get_checkspace(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/disable checking free space before installing packages.\n @param handle the context handle\n @param checkspace 0 for disabled, 1 for enabled"]
    pub fn alpm_option_set_checkspace(
        handle: *mut alpm_handle_t,
        checkspace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the configured database extension.\n @param handle the context handle\n @return the configured database extension"]
    pub fn alpm_option_get_dbext(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the database extension.\n @param handle the context handle\n @param dbext the database extension to use\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_dbext(
        handle: *mut alpm_handle_t,
        dbext: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the default siglevel.\n @param handle the context handle\n @return a \\link alpm_siglevel_t \\endlink bitfield of the siglevel"]
    pub fn alpm_option_get_default_siglevel(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the default siglevel.\n @param handle the context handle\n @param level a \\link alpm_siglevel_t \\endlink bitfield of the level to set\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_default_siglevel(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the configured local file siglevel.\n @param handle the context handle\n @return a \\link alpm_siglevel_t \\endlink bitfield of the siglevel"]
    pub fn alpm_option_get_local_file_siglevel(handle: *mut alpm_handle_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the local file siglevel.\n @param handle the context handle\n @param level a \\link alpm_siglevel_t \\endlink bitfield of the level to set\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_local_file_siglevel(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the configured remote file siglevel.\n @param handle the context handle\n @return a \\link alpm_siglevel_t \\endlink bitfield of the siglevel"]
    pub fn alpm_option_get_remote_file_siglevel(
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the remote file siglevel.\n @param handle the context handle\n @param level a \\link alpm_siglevel_t \\endlink bitfield of the level to set\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_remote_file_siglevel(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the download timeout state\n @param handle the context handle\n @return 0 for enabled, 1 for disabled"]
    pub fn alpm_option_get_disable_dl_timeout(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables/disables the download timeout.\n @param handle the context handle\n @param disable_dl_timeout 0 for enabled, 1 for disabled\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_disable_dl_timeout(
        handle: *mut alpm_handle_t,
        disable_dl_timeout: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of parallel streams to download database and package files.\n @param handle the context handle\n @return the number of parallel streams to download database and package files"]
    pub fn alpm_option_get_parallel_downloads(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets number of parallel streams to download database and package files.\n @param handle the context handle\n @param num_streams number of parallel download streams\n @return 0 on success, -1 on error"]
    pub fn alpm_option_set_parallel_downloads(
        handle: *mut alpm_handle_t,
        num_streams: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the sandbox state\n @param handle the context handle\n @return 0 for enabled, 1 for disabled"]
    pub fn alpm_option_get_disable_sandbox(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables/disables the sandbox.\n @param handle the context handle\n @param disable_sandbox 0 for enabled, 1 for disabled\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_option_set_disable_sandbox(
        handle: *mut alpm_handle_t,
        disable_sandbox: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Package install reasons."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_pkgreason_t {
    #[doc = " Explicitly requested by the user."]
    ALPM_PKG_REASON_EXPLICIT = 0,
    #[doc = " Installed as a dependency for another package."]
    ALPM_PKG_REASON_DEPEND = 1,
    #[doc = " Failed parsing of local database"]
    ALPM_PKG_REASON_UNKNOWN = 2,
}
#[doc = " Package install reasons."]
pub use self::_alpm_pkgreason_t as alpm_pkgreason_t;
#[repr(u32)]
#[doc = " Location a package object was loaded from."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_pkgfrom_t {
    #[doc = " Loaded from a file via \\link alpm_pkg_load \\endlink"]
    ALPM_PKG_FROM_FILE = 1,
    #[doc = " From the local database"]
    ALPM_PKG_FROM_LOCALDB = 2,
    #[doc = " From a sync database"]
    ALPM_PKG_FROM_SYNCDB = 3,
}
#[doc = " Location a package object was loaded from."]
pub use self::_alpm_pkgfrom_t as alpm_pkgfrom_t;
pub mod _alpm_pkgvalidation_t {
    #[doc = " Method used to validate a package."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " The package's validation type is unknown"]
    pub const ALPM_PKG_VALIDATION_UNKNOWN: Type = 0;
    #[doc = " The package does not have any validation"]
    pub const ALPM_PKG_VALIDATION_NONE: Type = 1;
    #[doc = " The package is validated with md5"]
    pub const ALPM_PKG_VALIDATION_MD5SUM: Type = 2;
    #[doc = " The package is validated with sha256"]
    pub const ALPM_PKG_VALIDATION_SHA256SUM: Type = 4;
    #[doc = " The package is validated with a PGP signature"]
    pub const ALPM_PKG_VALIDATION_SIGNATURE: Type = 8;
}
#[doc = " Method used to validate a package."]
pub use self::_alpm_pkgvalidation_t::Type as alpm_pkgvalidation_t;
extern "C" {
    #[doc = " Create a package from a file.\n If full is false, the archive is read only until all necessary\n metadata is found. If it is true, the entire archive is read, which\n serves as a verification of integrity and the filelist can be created.\n The allocated structure should be freed using alpm_pkg_free().\n @param handle the context handle\n @param filename location of the package tarball\n @param full whether to stop the load after metadata is read or continue\n through the full archive\n @param level what level of package signature checking to perform on the\n package; note that this must be a '.sig' file type verification\n @param pkg address of the package pointer\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_load(
        handle: *mut alpm_handle_t,
        filename: *const ::std::os::raw::c_char,
        full: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        pkg: *mut *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fetch a list of remote packages.\n @param handle the context handle\n @param urls list of package URLs to download\n @param fetched list of filepaths to the fetched packages, each item\n    corresponds to one in `urls` list. This is an output parameter,\n    the caller should provide a pointer to an empty list\n    (*fetched === NULL) and the callee fills the list with data.\n @return 0 on success or -1 on failure"]
    pub fn alpm_fetch_pkgurl(
        handle: *mut alpm_handle_t,
        urls: *const alpm_list_t,
        fetched: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a package in a list by name.\n @param haystack a list of alpm_pkg_t\n @param needle the package name\n @return a pointer to the package if found or NULL"]
    pub fn alpm_pkg_find(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    #[doc = " Free a package.\n Only packages loaded with \\link alpm_pkg_load \\endlink can be freed.\n Packages from databases will be freed by libalpm when they are unregistered.\n @param pkg package pointer to free\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_free(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the integrity (with md5) of a package from the sync cache.\n @param pkg package pointer\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_checkmd5sum(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two version strings and determine which one is 'newer'.\n Returns a value comparable to the way strcmp works. Returns 1\n if a is newer than b, 0 if a and b are the same version, or -1\n if b is newer than a.\n\n Different epoch values for version strings will override any further\n comparison. If no epoch is provided, 0 is assumed.\n\n Keep in mind that the pkgrel is only compared if it is available\n on both versions handed to this function. For example, comparing\n 1.5-1 and 1.5 will yield 0; comparing 1.5-1 and 1.5-2 will yield\n -1 as expected. This is mainly for supporting versioned dependencies\n that do not include the pkgrel."]
    pub fn alpm_pkg_vercmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the list of packages requiring a given package.\n The return value of this function is a newly allocated\n list of package names (char*), it should be freed by the caller.\n @param pkg a package\n @return the list of packages requiring pkg"]
    pub fn alpm_pkg_compute_requiredby(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Computes the list of packages optionally requiring a given package.\n The return value of this function is a newly allocated\n list of package names (char*), it should be freed by the caller.\n @param pkg a package\n @return the list of packages optionally requiring pkg"]
    pub fn alpm_pkg_compute_optionalfor(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Test if a package should be ignored.\n Checks if the package is ignored via IgnorePkg, or if the package is\n in a group ignored via IgnoreGroup.\n @param handle the context handle\n @param pkg the package to test\n @return 1 if the package should be ignored, 0 otherwise"]
    pub fn alpm_pkg_should_ignore(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the handle of a package\n @param pkg a pointer to package\n @return the alpm handle that the package belongs to"]
    pub fn alpm_pkg_get_handle(pkg: *mut alpm_pkg_t) -> *mut alpm_handle_t;
}
extern "C" {
    #[doc = " Gets the name of the file from which the package was loaded.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_filename(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package base name.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_base(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package name.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_name(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package version as a string.\n This includes all available epoch, version, and pkgrel components. Use\n alpm_pkg_vercmp() to compare version strings if necessary.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_version(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the origin of the package.\n @return an alpm_pkgfrom_t constant, -1 on error"]
    pub fn alpm_pkg_get_origin(pkg: *mut alpm_pkg_t) -> alpm_pkgfrom_t;
}
extern "C" {
    #[doc = " Returns the package description.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_desc(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package URL.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_url(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the build timestamp of the package.\n @param pkg a pointer to package\n @return the timestamp of the build time"]
    pub fn alpm_pkg_get_builddate(pkg: *mut alpm_pkg_t) -> alpm_time_t;
}
extern "C" {
    #[doc = " Returns the install timestamp of the package.\n @param pkg a pointer to package\n @return the timestamp of the install time"]
    pub fn alpm_pkg_get_installdate(pkg: *mut alpm_pkg_t) -> alpm_time_t;
}
extern "C" {
    #[doc = " Returns the packager's name.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_packager(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package's MD5 checksum as a string.\n The returned string is a sequence of 32 lowercase hexadecimal digits.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_md5sum(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package's SHA256 checksum as a string.\n The returned string is a sequence of 64 lowercase hexadecimal digits.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_sha256sum(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the architecture for which the package was built.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_arch(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the size of the package. This is only available for sync database\n packages and package files, not those loaded from the local database.\n @param pkg a pointer to package\n @return the size of the package in bytes."]
    pub fn alpm_pkg_get_size(pkg: *mut alpm_pkg_t) -> off_t;
}
extern "C" {
    #[doc = " Returns the installed size of the package.\n @param pkg a pointer to package\n @return the total size of files installed by the package."]
    pub fn alpm_pkg_get_isize(pkg: *mut alpm_pkg_t) -> off_t;
}
extern "C" {
    #[doc = " Returns the package installation reason.\n @param pkg a pointer to package\n @return an enum member giving the install reason."]
    pub fn alpm_pkg_get_reason(pkg: *mut alpm_pkg_t) -> alpm_pkgreason_t;
}
extern "C" {
    #[doc = " Returns the list of package licenses.\n @param pkg a pointer to package\n @return a pointer to an internal list of strings."]
    pub fn alpm_pkg_get_licenses(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of package groups.\n @param pkg a pointer to package\n @return a pointer to an internal list of strings."]
    pub fn alpm_pkg_get_groups(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of package dependencies as alpm_depend_t.\n @param pkg a pointer to package\n @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_depends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of package optional dependencies.\n @param pkg a pointer to package\n @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_optdepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns a list of package check dependencies\n @param pkg a pointer to package\n @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_checkdepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns a list of package make dependencies\n @param pkg a pointer to package\n @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_makedepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages conflicting with pkg.\n @param pkg a pointer to package\n @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_conflicts(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages provided by pkg.\n @param pkg a pointer to package\n @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_provides(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages to be replaced by pkg.\n @param pkg a pointer to package\n @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_replaces(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of files installed by pkg.\n The filenames are relative to the install root,\n and do not include leading slashes.\n @param pkg a pointer to package\n @return a pointer to a filelist object containing a count and an array of\n package file objects"]
    pub fn alpm_pkg_get_files(pkg: *mut alpm_pkg_t) -> *mut alpm_filelist_t;
}
extern "C" {
    #[doc = " Returns the list of files backed up when installing pkg.\n @param pkg a pointer to package\n @return a reference to a list of alpm_backup_t objects"]
    pub fn alpm_pkg_get_backup(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the database containing pkg.\n Returns a pointer to the alpm_db_t structure the package is\n originating from, or NULL if the package was loaded from a file.\n @param pkg a pointer to package\n @return a pointer to the DB containing pkg, or NULL."]
    pub fn alpm_pkg_get_db(pkg: *mut alpm_pkg_t) -> *mut alpm_db_t;
}
extern "C" {
    #[doc = " Returns the base64 encoded package signature.\n @param pkg a pointer to package\n @return a reference to an internal string"]
    pub fn alpm_pkg_get_base64_sig(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Extracts package signature either from embedded package signature\n or if it is absent then reads data from detached signature file.\n @param pkg a pointer to package.\n @param sig output parameter for signature data. Callee function allocates\n a buffer needed for the signature data. Caller is responsible for\n freeing this buffer.\n @param sig_len output parameter for the signature data length.\n @return 0 on success, negative number on error."]
    pub fn alpm_pkg_get_sig(
        pkg: *mut alpm_pkg_t,
        sig: *mut *mut ::std::os::raw::c_uchar,
        sig_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the method used to validate a package during install.\n @param pkg a pointer to package\n @return an enum member giving the validation method"]
    pub fn alpm_pkg_get_validation(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the extended data field of a package.\n @param pkg a pointer to package\n @return a reference to a list of alpm_pkg_xdata_t objects"]
    pub fn alpm_pkg_get_xdata(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns whether the package has an install scriptlet.\n @return 0 if FALSE, TRUE otherwise"]
    pub fn alpm_pkg_has_scriptlet(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the size of the files that will be downloaded to install a\n package.\n @param newpkg the new package to upgrade to\n @return the size of the download"]
    pub fn alpm_pkg_download_size(newpkg: *mut alpm_pkg_t) -> off_t;
}
extern "C" {
    #[doc = " Set install reason for a package in the local database.\n The provided package object must be from the local database or this method\n will fail. The write to the local database is performed immediately.\n @param pkg the package to update\n @param reason the new install reason\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_set_reason(
        pkg: *mut alpm_pkg_t,
        reason: alpm_pkgreason_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a package changelog for reading.\n Similar to fopen in functionality, except that the returned 'file\n stream' could really be from an archive as well as from the database.\n @param pkg the package to read the changelog of (either file or db)\n @return a 'file stream' to the package changelog"]
    pub fn alpm_pkg_changelog_open(pkg: *mut alpm_pkg_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Read data from an open changelog 'file stream'.\n Similar to fread in functionality, this function takes a buffer and\n amount of data to read. If an error occurs pm_errno will be set.\n @param ptr a buffer to fill with raw changelog data\n @param size the size of the buffer\n @param pkg the package that the changelog is being read from\n @param fp a 'file stream' to the package changelog\n @return the number of characters read, or 0 if there is no more data or an\n error occurred."]
    pub fn alpm_pkg_changelog_read(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " Close a package changelog for reading.\n @param pkg the package to close the changelog of (either file or db)\n @param fp the 'file stream' to the package changelog to close\n @return 0 on success, -1 on error"]
    pub fn alpm_pkg_changelog_close(
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a package mtree file for reading.\n @param pkg the local package to read the mtree of\n @return an archive structure for the package mtree file"]
    pub fn alpm_pkg_mtree_open(pkg: *mut alpm_pkg_t) -> *mut archive;
}
extern "C" {
    #[doc = " Read next entry from a package mtree file.\n @param pkg the package that the mtree file is being read from\n @param archive the archive structure reading from the mtree file\n @param entry an archive_entry to store the entry header information\n @return 0 on success, 1 if end of archive is reached, -1 otherwise."]
    pub fn alpm_pkg_mtree_next(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
        entry: *mut *mut archive_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a package mtree file.\n @param pkg the local package to close the mtree of\n @param archive the archive to close"]
    pub fn alpm_pkg_mtree_close(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
    ) -> ::std::os::raw::c_int;
}
pub mod _alpm_transflag_t {
    #[doc = " Transaction flags"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Ignore dependency checks."]
    pub const ALPM_TRANS_FLAG_NODEPS: Type = 1;
    #[doc = " Delete files even if they are tagged as backup."]
    pub const ALPM_TRANS_FLAG_NOSAVE: Type = 4;
    #[doc = " Ignore version numbers when checking dependencies."]
    pub const ALPM_TRANS_FLAG_NODEPVERSION: Type = 8;
    #[doc = " Remove also any packages depending on a package being removed."]
    pub const ALPM_TRANS_FLAG_CASCADE: Type = 16;
    #[doc = " Remove packages and their unneeded deps (not explicitly installed)."]
    pub const ALPM_TRANS_FLAG_RECURSE: Type = 32;
    #[doc = " Modify database but do not commit changes to the filesystem."]
    pub const ALPM_TRANS_FLAG_DBONLY: Type = 64;
    #[doc = " Do not run hooks during a transaction"]
    pub const ALPM_TRANS_FLAG_NOHOOKS: Type = 128;
    #[doc = " Use ALPM_PKG_REASON_DEPEND when installing packages."]
    pub const ALPM_TRANS_FLAG_ALLDEPS: Type = 256;
    #[doc = " Only download packages and do not actually install."]
    pub const ALPM_TRANS_FLAG_DOWNLOADONLY: Type = 512;
    #[doc = " Do not execute install scriptlets after installing."]
    pub const ALPM_TRANS_FLAG_NOSCRIPTLET: Type = 1024;
    #[doc = " Ignore dependency conflicts."]
    pub const ALPM_TRANS_FLAG_NOCONFLICTS: Type = 2048;
    #[doc = " Do not install a package if it is already installed and up to date."]
    pub const ALPM_TRANS_FLAG_NEEDED: Type = 8192;
    #[doc = " Use ALPM_PKG_REASON_EXPLICIT when installing packages."]
    pub const ALPM_TRANS_FLAG_ALLEXPLICIT: Type = 16384;
    #[doc = " Do not remove a package if it is needed by another one."]
    pub const ALPM_TRANS_FLAG_UNNEEDED: Type = 32768;
    #[doc = " Remove also explicitly installed unneeded deps (use with ALPM_TRANS_FLAG_RECURSE)."]
    pub const ALPM_TRANS_FLAG_RECURSEALL: Type = 65536;
    #[doc = " Do not lock the database during the operation."]
    pub const ALPM_TRANS_FLAG_NOLOCK: Type = 131072;
}
#[doc = " Transaction flags"]
pub use self::_alpm_transflag_t::Type as alpm_transflag_t;
extern "C" {
    #[doc = " Returns the bitfield of flags for the current transaction.\n @param handle the context handle\n @return the bitfield of transaction flags"]
    pub fn alpm_trans_get_flags(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a list of packages added by the transaction.\n @param handle the context handle\n @return a list of alpm_pkg_t structures"]
    pub fn alpm_trans_get_add(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages removed by the transaction.\n @param handle the context handle\n @return a list of alpm_pkg_t structures"]
    pub fn alpm_trans_get_remove(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Initialize the transaction.\n @param handle the context handle\n @param flags flags of the transaction (like nodeps, etc; see alpm_transflag_t)\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_init(
        handle: *mut alpm_handle_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prepare a transaction.\n @param handle the context handle\n @param data the address of an alpm_list where a list\n of alpm_depmissing_t objects is dumped (conflicting packages)\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_prepare(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Commit a transaction.\n @param handle the context handle\n @param data the address of an alpm_list where detailed description\n of an error can be dumped (i.e. list of conflicting files)\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_commit(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Interrupt a transaction.\n @param handle the context handle\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_interrupt(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release a transaction.\n @param handle the context handle\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_release(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for packages to upgrade and add them to the transaction.\n @param handle the context handle\n @param enable_downgrade allow downgrading of packages if the remote version is lower\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_sync_sysupgrade(
        handle: *mut alpm_handle_t,
        enable_downgrade: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a package to the transaction.\n If the package was loaded by alpm_pkg_load(), it will be freed upon\n \\link alpm_trans_release \\endlink invocation.\n @param handle the context handle\n @param pkg the package to add\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_add_pkg(handle: *mut alpm_handle_t, pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a package removal to the transaction.\n @param handle the context handle\n @param pkg the package to uninstall\n @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_remove_pkg(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check for new version of pkg in syncdbs.\n\n If the same package appears multiple dbs only the first will be checked\n\n This only checks the syncdb for a newer version. It does not access the network at all.\n See \\link alpm_db_update \\endlink to update a database."]
    pub fn alpm_sync_get_new_version(
        pkg: *mut alpm_pkg_t,
        dbs_sync: *mut alpm_list_t,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    #[doc = " Get the md5 sum of file.\n @param filename name of the file\n @return the checksum on success, NULL on error"]
    pub fn alpm_compute_md5sum(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the sha256 sum of file.\n @param filename name of the file\n @return the checksum on success, NULL on error"]
    pub fn alpm_compute_sha256sum(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Remove the database lock file\n @param handle the context handle\n @return 0 on success, -1 on error\n\n @note Safe to call from inside signal handlers."]
    pub fn alpm_unlock(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
pub mod alpm_caps {
    #[doc = " Enum of possible compile time features"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " localization"]
    pub const ALPM_CAPABILITY_NLS: Type = 1;
    #[doc = " Ability to download"]
    pub const ALPM_CAPABILITY_DOWNLOADER: Type = 2;
    #[doc = " Signature checking"]
    pub const ALPM_CAPABILITY_SIGNATURES: Type = 4;
}
extern "C" {
    #[doc = " Get the version of library.\n @return the library version, e.g. \"6.0.4\""]
    pub fn alpm_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the capabilities of the library.\n @return a bitmask of the capabilities"]
    pub fn alpm_capabilities() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Drop privileges by switching to a different user.\n @param handle the context handle\n @param sandboxuser the user to switch to\n @param sandbox_path if non-NULL, restrict writes to this filesystem path\n @param restrict_syscalls whether to deny access to a list of dangerous syscalls\n @return 0 on success, -1 on failure"]
    pub fn alpm_sandbox_setup_child(
        handle: *mut alpm_handle_t,
        sandboxuser: *const ::std::os::raw::c_char,
        sandbox_path: *const ::std::os::raw::c_char,
        restrict_syscalls: bool,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
